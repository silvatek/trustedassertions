
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">silvatek.uk/trustedassertions/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">silvatek.uk/trustedassertions/cmd/utils/main.go (0.0%)</option>
				
				<option value="file2">silvatek.uk/trustedassertions/internal/api/handlers.go (75.0%)</option>
				
				<option value="file3">silvatek.uk/trustedassertions/internal/appcontext/context.go (60.0%)</option>
				
				<option value="file4">silvatek.uk/trustedassertions/internal/assertions/assertions.go (46.3%)</option>
				
				<option value="file5">silvatek.uk/trustedassertions/internal/assertions/resolver.go (61.9%)</option>
				
				<option value="file6">silvatek.uk/trustedassertions/internal/auth/userjwt.go (87.5%)</option>
				
				<option value="file7">silvatek.uk/trustedassertions/internal/auth/users.go (100.0%)</option>
				
				<option value="file8">silvatek.uk/trustedassertions/internal/datastore/controller.go (87.2%)</option>
				
				<option value="file9">silvatek.uk/trustedassertions/internal/datastore/datastore.go (41.7%)</option>
				
				<option value="file10">silvatek.uk/trustedassertions/internal/datastore/firestore.go (17.5%)</option>
				
				<option value="file11">silvatek.uk/trustedassertions/internal/datastore/memorystore.go (77.6%)</option>
				
				<option value="file12">silvatek.uk/trustedassertions/internal/docs/docs.go (59.1%)</option>
				
				<option value="file13">silvatek.uk/trustedassertions/internal/entities/entities.go (58.5%)</option>
				
				<option value="file14">silvatek.uk/trustedassertions/internal/logging/logger.go (88.5%)</option>
				
				<option value="file15">silvatek.uk/trustedassertions/internal/logging/logging.go (67.6%)</option>
				
				<option value="file16">silvatek.uk/trustedassertions/internal/references/hashuri.go (87.5%)</option>
				
				<option value="file17">silvatek.uk/trustedassertions/internal/references/referenceable.go (37.5%)</option>
				
				<option value="file18">silvatek.uk/trustedassertions/internal/search/search.go (95.2%)</option>
				
				<option value="file19">silvatek.uk/trustedassertions/internal/statements/statements.go (50.0%)</option>
				
				<option value="file20">silvatek.uk/trustedassertions/internal/web/attack_handlers.go (46.2%)</option>
				
				<option value="file21">silvatek.uk/trustedassertions/internal/web/authcookie.go (100.0%)</option>
				
				<option value="file22">silvatek.uk/trustedassertions/internal/web/authhandlers.go (78.2%)</option>
				
				<option value="file23">silvatek.uk/trustedassertions/internal/web/dochandlers.go (16.1%)</option>
				
				<option value="file24">silvatek.uk/trustedassertions/internal/web/errors.go (81.2%)</option>
				
				<option value="file25">silvatek.uk/trustedassertions/internal/web/handlers.go (81.4%)</option>
				
				<option value="file26">silvatek.uk/trustedassertions/internal/web/pagemenu.go (84.6%)</option>
				
				<option value="file27">silvatek.uk/trustedassertions/internal/web/qrcodes.go (61.1%)</option>
				
				<option value="file28">silvatek.uk/trustedassertions/internal/webtest/webtest.go (73.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "time"

        "silvatek.uk/trustedassertions/internal/api"
        "silvatek.uk/trustedassertions/internal/appcontext"
        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/datastore"
        "silvatek.uk/trustedassertions/internal/logging"
        . "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/testdata"
        "silvatek.uk/trustedassertions/internal/web"

        "github.com/gorilla/csrf"
        "github.com/gorilla/handlers"
        "github.com/gorilla/mux"
)

var testDataDir string
var defaultEntityUri string
var defaultEntityKey string

var log = logging.GetLogger("main")

func main() <span class="cov0" title="0">{
        ctx := appcontext.InitContext()
        initLogging()
        log.InfofX(ctx, "Starting TrustedAssertions server...")

        testDataDir = "./testdata"
        initDataStore(ctx)

        web.TemplateDir = "./web"
        r := setupHandlers()

        CSRF := csrf.Protect(
                []byte(os.Getenv("CSRF_KEY")),
                csrf.SameSite(csrf.SameSiteStrictMode),
                csrf.FieldName("authenticity_token"),
                csrf.Path("/"),
                csrf.CookieName("authenticity_token"),
        )
        handlers.CompressHandler(r)

        srv := &amp;http.Server{
                Handler:      CSRF(r),
                Addr:         listenAddress(),
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 5 * time.Second,
        }

        srv.ListenAndServe()
}</span>

func setupHandlers() *mux.Router <span class="cov0" title="0">{
        r := mux.NewRouter()

        api.AddHandlers(r)

        web.AddHandlers(r)

        r.HandleFunc("/api/v1/initdb", InitDbApiHandler)

        return r
}</span>

func initDataStore(ctx context.Context) <span class="cov0" title="0">{
        if os.Getenv("FIRESTORE_DB_NAME") != "" </span><span class="cov0" title="0">{
                datastore.InitFireStore(ctx)
        }</span> else<span class="cov0" title="0"> {
                datastore.InitInMemoryDataStore()
        }</span>

        <span class="cov0" title="0">if defaultEntityUri == "" </span><span class="cov0" title="0">{
                defaultEntityUri = os.Getenv("DEFAULT_ENTITY")
                web.DefaultEntityUri = UriFromString(defaultEntityUri)
        }</span>

        <span class="cov0" title="0">if defaultEntityKey == "" </span><span class="cov0" title="0">{
                defaultEntityKey = os.Getenv("PRV_KEY")
        }</span>

        <span class="cov0" title="0">assertions.PublicKeyResolver = datastore.ActiveDataStore

        if datastore.ActiveDataStore.AutoInit() </span><span class="cov0" title="0">{
                testdata.SetupTestData(ctx, testDataDir, defaultEntityUri, defaultEntityKey)
        }</span>
}

func initLogging() <span class="cov0" title="0">{
        logging.StructureLogs = (os.Getenv("GCLOUD_PROJECT") != "")
}</span>

func InitDbApiHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        testdata.SetupTestData(context.Background(), testDataDir, defaultEntityUri, defaultEntityKey)
        w.WriteHeader(http.StatusOK)
        w.Header().Set("Content-Type", "text/plain")
        w.Write([]byte("Data store initialised"))
}</span>

func listenAddress() string <span class="cov0" title="0">{
        envPort := os.Getenv("PORT")
        if len(envPort) &gt; 0 </span><span class="cov0" title="0">{
                return ":" + envPort
        }</span> else<span class="cov0" title="0"> {
                return "127.0.0.1:8080"
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "math/big"
        "os"

        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/entities"
        log "silvatek.uk/trustedassertions/internal/logging"
        "silvatek.uk/trustedassertions/internal/statements"
)

func main() <span class="cov0" title="0">{

        log.StructureLogs = (os.Getenv("GCLOUD_PROJECT") != "")
        log.Info("TrustedAssertions utils")

        b64key := os.Getenv("PRV_KEY")
        prvKey := entities.PrivateKeyFromString(b64key)
        err := prvKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Private key is not valid: %v", err)
                return
        }</span>

        <span class="cov0" title="0">log.Infof("Key: %s", b64key[len(b64key)-8:])

        entity := entities.NewEntity("Mr Tester", *big.NewInt(8376446832743937489))
        entity.MakeCertificate(prvKey)

        u := entity.Uri()
        log.Infof("Certificate URI: %s", u)
        hash := u.Hash()

        dirName := "./testdata"

        err = os.WriteFile(dirName+"/"+hash+".txt", []byte(entity.Content()), 0777)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error writing file %v", err)
        }</span>

        <span class="cov0" title="0">statement := statements.NewStatement("The universe exists")
        log.Infof("Statement URI: %s", statement.Uri())
        u = statement.Uri()
        hash = u.Hash()

        err = os.WriteFile(dirName+"/"+hash+".txt", []byte(statement.Content()), 0777)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error writing file %v", err)
        }</span>

        <span class="cov0" title="0">assertion := assertions.NewAssertion("IsTrue")
        assertion.Subject = u.String()
        assertion.SetAssertingEntity(entity)
        assertion.MakeJwt(prvKey)
        log.Infof("Assertion URI: %s", assertion.Uri())
        u = assertion.Uri()
        hash = u.Hash()

        err = os.WriteFile(dirName+"/"+hash+".txt", []byte(assertion.Content()), 0777)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error writing file %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"

        "github.com/gorilla/mux"
        "silvatek.uk/trustedassertions/internal/appcontext"
        "silvatek.uk/trustedassertions/internal/datastore"
        log "silvatek.uk/trustedassertions/internal/logging"
        "silvatek.uk/trustedassertions/internal/references"
)

func AddHandlers(r *mux.Router) <span class="cov8" title="1">{
        r.HandleFunc("/api/v1/statements/{key}", StatementApiHandler)
        r.HandleFunc("/api/v1/entities/{key}", EntityApiHandler)
        r.HandleFunc("/api/v1/assertions/{key}", AssertionApiHandler)

        //r.HandleFunc("/api/v1/reindex", ReindexApiHandler)
}</span>

func StatementApiHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        key := mux.Vars(r)["key"]
        log.Debugf("Statement key: %s", key)

        statement, err := datastore.ActiveDataStore.FetchStatement(ctx, references.MakeUri(key, "statement"))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error fetching statement: %v", err)
        }</span>

        <span class="cov8" title="1">setHeaders(w, http.StatusOK, "text/plain")
        w.Write([]byte(statement.Content()))</span>
}

func EntityApiHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        key := mux.Vars(r)["key"]
        entity, _ := datastore.ActiveDataStore.FetchEntity(ctx, references.MakeUri(key, "entity"))

        setHeaders(w, http.StatusOK, "text/plain")
        w.Write([]byte(entity.Certificate))
}</span>

func AssertionApiHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        key := mux.Vars(r)["key"]
        assertion, err := datastore.ActiveDataStore.FetchAssertion(ctx, references.MakeUri(key, "assertion"))

        if err != nil </span><span class="cov0" title="0">{
                setHeaders(w, http.StatusInternalServerError, "text/plain")
                w.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">setHeaders(w, http.StatusOK, "text/plain")
        w.Write([]byte(assertion.Content()))</span>
}

func ReindexApiHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setHeaders(w, http.StatusOK, "text/plain")
        w.Write([]byte("Reindexing..."))

        datastore.ActiveDataStore.Reindex()

        w.Write([]byte("Done"))
}</span>

func setHeaders(w http.ResponseWriter, httpStatus int, contentType string) <span class="cov8" title="1">{
        w.WriteHeader(httpStatus)
        w.Header().Set("Content-Type", contentType)
        w.Header().Set("X-Robots-Tag", "noindex")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package appcontext

import (
        "context"
        "net/http"
)

type CtxData struct {
        ReqPath     string
        ReqMethod   string
        TraceParent string
}

type key int

const ctxDataKey key = 0

func NewWebContext(req *http.Request) context.Context <span class="cov8" title="1">{
        return WebContext(req.Context(), req)
}</span>

// Custom context for web requests
func WebContext(parent context.Context, req *http.Request) context.Context <span class="cov8" title="1">{
        var data CtxData

        data.ReqPath = req.URL.Path
        data.ReqMethod = req.Method
        data.TraceParent = req.Header.Get("traceparent")

        return context.WithValue(parent, ctxDataKey, data)
}</span>

// Custom context for server startup
func InitContext() context.Context <span class="cov0" title="0">{
        var data CtxData

        data.ReqPath = "{INIT}"
        data.ReqMethod = "{INIT}"
        data.TraceParent = ""

        return context.WithValue(context.Background(), ctxDataKey, data)
}</span>

// Returns the data associated with the context.
// If there is no associated data, returns an empty structure.
func ContextData(ctx context.Context) (CtxData, bool) <span class="cov8" title="1">{
        val := ctx.Value(ctxDataKey)
        if val == nil </span><span class="cov8" title="1">{
                return CtxData{}, false
        }</span>

        <span class="cov0" title="0">return val.(CtxData), true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package assertions

import (
        "context"
        "crypto/rsa"
        "errors"
        "fmt"
        "strings"

        "github.com/golang-jwt/jwt/v5"
        "silvatek.uk/trustedassertions/internal/entities"
        "silvatek.uk/trustedassertions/internal/logging"
        "silvatek.uk/trustedassertions/internal/references"
        refs "silvatek.uk/trustedassertions/internal/references"
)

const DEFAULT_AUDIENCE = "trustedassertions:0.1/any"
const UNDEFINED_CATEGORY = "Undefined"

type Assertion struct {
        *jwt.RegisteredClaims
        Category   string       `json:"category,omitempty"`
        Confidence float32      `json:"confidence,omitempty"`
        Object     string       `json:"object,omitempty"`
        content    string       `json:"-"`
        uri        refs.HashUri `json:"-"`
        summary    string       `json:"-"`
}

// Resolver used to fetch public keys for entities.
var PublicKeyResolver Resolver

var log = logging.GetLogger("assertions")

func NewAssertion(category string) Assertion <span class="cov8" title="1">{
        return Assertion{
                Category:   category,
                Confidence: 0.0,
                RegisteredClaims: &amp;jwt.RegisteredClaims{
                        Audience: []string{DEFAULT_AUDIENCE},
                },
        }
}</span>

// Returns the public key to be used to verify the specified JWT token.
// The token issuer should be the URI of an entity, and that entity is fetched using the PublicKeyResolver.
func verificationKey(token *jwt.Token) (interface{}, error) <span class="cov8" title="1">{
        entityUri, _ := token.Claims.GetIssuer()
        entity, err := PublicKeyResolver.FetchEntity(context.Background(), refs.UriFromString(entityUri))
        return entity.PublicKey, err
}</span>

func (a *Assertion) ParseContent(content string) error <span class="cov8" title="1">{
        a.content = content

        if content == "" </span><span class="cov0" title="0">{
                return errors.New("unable to parse empty JWT")
        }</span>

        <span class="cov8" title="1">a.RegisteredClaims = &amp;jwt.RegisteredClaims{}

        _, err := jwt.ParseWithClaims(content, a, verificationKey)

        return err</span>
}

func ParseAssertionJwt(token string) (Assertion, error) <span class="cov8" title="1">{
        template := Assertion{
                RegisteredClaims: &amp;jwt.RegisteredClaims{},
        }

        if token == "" </span><span class="cov0" title="0">{
                return template, errors.New("unable to parse empty JWT")
        }</span>

        <span class="cov8" title="1">parsed, err := jwt.ParseWithClaims(token, &amp;template, verificationKey)
        if err != nil </span><span class="cov0" title="0">{
                return template, err
        }</span>

        <span class="cov8" title="1">if assertion, ok := parsed.Claims.(*Assertion); ok &amp;&amp; parsed.Valid </span><span class="cov8" title="1">{
                assertion.content = token
                return *assertion, nil
        }</span> else<span class="cov0" title="0"> {
                return *assertion, errors.New("unable to parse JWT claims")
        }</span>
}

func (a *Assertion) MakeJwt(privateKey *rsa.PrivateKey) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, a)
        signed, err := token.SignedString(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error creating signed JWT")
                return
        }</span>
        <span class="cov8" title="1">a.content = signed</span>
}

func (a *Assertion) Uri() refs.HashUri <span class="cov8" title="1">{
        if a.uri.IsEmpty() </span><span class="cov8" title="1">{
                if a.content == "" </span><span class="cov0" title="0">{
                        log.Errorf("Attempting to get URI for empty assertion content")
                        return refs.ERROR_URI
                }</span>
                <span class="cov8" title="1">a.uri = refs.UriFor(a)</span>
        }
        <span class="cov8" title="1">return a.uri</span>
}

func (a *Assertion) Type() string <span class="cov8" title="1">{
        return "Assertion"
}</span>

func (a *Assertion) Content() string <span class="cov8" title="1">{
        if a.content == "" </span><span class="cov0" title="0">{
                log.Errorf("Attempting to get URI for empty assertion content")
        }</span>
        <span class="cov8" title="1">return a.content</span>
}

func (a *Assertion) Summary() string <span class="cov8" title="1">{
        if a.summary == "" </span><span class="cov8" title="1">{
                a.summary = a.Category + " assertion"
        }</span>
        <span class="cov8" title="1">return a.summary</span>
}

func (a *Assertion) SetSummary(summary string) <span class="cov0" title="0">{
        a.summary = summary
}</span>

func (a *Assertion) TextContent() string <span class="cov0" title="0">{
        return "" // Assertions aren't directly searchable
}</span>

func (a Assertion) References() []refs.HashUri <span class="cov0" title="0">{
        references := make([]refs.HashUri, 0)
        if a.RegisteredClaims.Issuer != "" </span><span class="cov0" title="0">{
                references = append(references, refs.UriFromString(a.RegisteredClaims.Issuer))
        }</span>
        <span class="cov0" title="0">if a.RegisteredClaims.Subject != "" </span><span class="cov0" title="0">{
                references = append(references, refs.UriFromString(a.RegisteredClaims.Subject))
        }</span>
        <span class="cov0" title="0">return references</span>
}

func (a *Assertion) SetAssertingEntity(entity entities.Entity) <span class="cov8" title="1">{
        a.RegisteredClaims.Issuer = entity.Uri().String()
}</span>

func CategoryDescription(category string, language string) string <span class="cov0" title="0">{
        if strings.HasPrefix(language, "en") </span><span class="cov0" title="0">{
                switch category </span>{
                case "IsTrue":<span class="cov0" title="0">
                        return "is true"</span>
                case "IsFalse":<span class="cov0" title="0">
                        return "is false"</span>
                default:<span class="cov0" title="0">
                        return category</span>
                }

        } else<span class="cov0" title="0"> {
                return category
        }</span>
}

func SummariseAssertion(ctx context.Context, assertion Assertion, target *references.Referenceable, resolver Resolver) string <span class="cov0" title="0">{
        issuerUri := references.UriFromString(assertion.Issuer)
        var issuerName string

        if target != nil &amp;&amp; issuerUri.Equals((*target).Uri()) </span><span class="cov0" title="0">{
                issuerName = (*target).Summary()
        }</span> else<span class="cov0" title="0"> {
                entity, _ := resolver.FetchEntity(ctx, issuerUri)
                issuerName = entity.Summary()
        }</span>

        <span class="cov0" title="0">subjectUri := references.UriFromString(assertion.Subject)
        var subjectSummary string

        if target != nil &amp;&amp; subjectUri.Equals((*target).Uri()) </span><span class="cov0" title="0">{
                subjectSummary = (*target).Summary()
        }</span> else<span class="cov0" title="0"> {
                subject, _ := resolver.FetchStatement(ctx, subjectUri)
                subjectSummary = subject.Summary()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s claims that '%s' %s", issuerName, subjectSummary, CategoryDescription(assertion.Category, "en"))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package assertions

import (
        "context"
        "errors"
        "strings"

        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        . "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/statements"
)

// Resolver is responsible for fetching the data associated with a Hash URI.
type Resolver interface {
        FetchStatement(ctx context.Context, key HashUri) (statements.Statement, error)
        FetchEntity(ctx context.Context, key HashUri) (entities.Entity, error)
        FetchAssertion(ctx context.Context, key HashUri) (Assertion, error)
        FetchDocument(ctx context.Context, key HashUri) (docs.Document, error)
        FetchKey(entityUri HashUri) (string, error)
        FetchRefs(ctx context.Context, key HashUri) ([]Reference, error)
}

type NullResolver struct{}

var ErrNotImplemented = errors.New("not implemented")

func (r NullResolver) FetchStatement(ctx context.Context, key HashUri) (statements.Statement, error) <span class="cov0" title="0">{
        return statements.Statement{}, ErrNotImplemented
}</span>

func (r NullResolver) FetchEntity(ctx context.Context, key HashUri) (entities.Entity, error) <span class="cov0" title="0">{
        return entities.Entity{}, ErrNotImplemented
}</span>

func (r NullResolver) FetchAssertion(ctx context.Context, key HashUri) (Assertion, error) <span class="cov0" title="0">{
        return Assertion{}, ErrNotImplemented
}</span>

func (r NullResolver) FetchDocument(ctx context.Context, key HashUri) (docs.Document, error) <span class="cov0" title="0">{
        return docs.Document{}, ErrNotImplemented
}</span>

func (r NullResolver) FetchKey(key HashUri) (string, error) <span class="cov0" title="0">{
        return "", ErrNotImplemented
}</span>

func (r NullResolver) FetchRefs(ctx context.Context, key HashUri) ([]Reference, error) <span class="cov0" title="0">{
        return []Reference{}, ErrNotImplemented
}</span>

func NewReferenceable(kind string) Referenceable <span class="cov8" title="1">{
        switch strings.ToLower(kind) </span>{
        case "statement":<span class="cov8" title="1">
                return &amp;statements.Statement{}</span>
        case "entity":<span class="cov8" title="1">
                return &amp;entities.Entity{}</span>
        case "assertion":<span class="cov8" title="1">
                return &amp;Assertion{}</span>
        case "document":<span class="cov8" title="1">
                return &amp;docs.Document{}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func GuessContentType(content string) string <span class="cov8" title="1">{
        if len(content) &lt; 512 </span><span class="cov8" title="1">{
                // Both X509 certificates and JWTs signed by Entities are longer than 512 characters
                return "Statement"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(content, "-----BEGIN CERTIFICATE----") </span><span class="cov8" title="1">{
                // X509 certificates for Entities are self-describing
                return "Entity"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(content, "eyJ") </span><span class="cov8" title="1">{
                // Assertion JWTs start with bas64-encoded "{"
                return "Assertion"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(content, "&lt;?xml") &amp;&amp; strings.Contains(content, "&lt;document&gt;") </span><span class="cov0" title="0">{
                return "Document"
        }</span>
        <span class="cov8" title="1">return "Statement"</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "crypto/rand"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

const ISSUER = "trustedassertions"

// Makes a shared key for signing user JWTs for our own consumption
func MakeJwtKey() []byte <span class="cov8" title="1">{
        key := make([]byte, 10)
        rand.Reader.Read(key)
        return key
}</span>

func MakeUserJwt(userId string, jwtKey []byte) (string, error) <span class="cov8" title="1">{
        ttl := 1 * time.Hour

        claims := jwt.MapClaims{
                "iss": ISSUER,
                "aud": ISSUER,
                "sub": userId,
                "iat": time.Now().UTC().Unix(),
                "exp": time.Now().UTC().Add(ttl).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signed, err := token.SignedString(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return signed, nil</span>
}

func ParseUserJwt(token string, jwtKey []byte) (string, error) <span class="cov8" title="1">{
        keyFunc := func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtKey, nil
        }</span>

        <span class="cov8" title="1">userToken, err := jwt.Parse(token, keyFunc,
                jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
                jwt.WithIssuer(ISSUER),
                jwt.WithAudience(ISSUER),
                jwt.WithIssuedAt(),
        )

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return userToken.Claims.GetSubject()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "encoding/base64"

        "golang.org/x/crypto/bcrypt"
        log "silvatek.uk/trustedassertions/internal/logging"
)

type User struct {
        Id       string `json:"id"`
        PassHash string `json:"passhash"`
        KeyRefs  []KeyRef
}

type KeyRef struct {
        UserId  string `json:"user_id"`
        KeyId   string `json:"key_id"`
        Summary string `json:"summary"`
}

func (u *User) AddKeyRef(keyId string, summary string) <span class="cov8" title="1">{
        if u.KeyRefs == nil </span><span class="cov8" title="1">{
                u.KeyRefs = make([]KeyRef, 0)
        }</span>
        <span class="cov8" title="1">u.KeyRefs = append(u.KeyRefs, KeyRef{UserId: u.Id, KeyId: keyId, Summary: summary})</span>
}

var DefaultHashCost int = bcrypt.DefaultCost

func (u *User) HashPassword(plaintext string) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(plaintext), DefaultHashCost)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Error hashing password: %v", err)
                return
        }</span>
        <span class="cov8" title="1">u.PassHash = base64.StdEncoding.EncodeToString(bytes)</span>
}

func (u *User) CheckHash(plaintext string) bool <span class="cov8" title="1">{
        if u.PassHash == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">bytes, err := base64.StdEncoding.DecodeString(u.PassHash)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Error decoding password hash: %v", err)
                return false
        }</span>
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword(bytes, []byte(plaintext))
        return err == nil</span>
}

func (u *User) HasKey(keyId string) bool <span class="cov8" title="1">{
        if u.KeyRefs == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, k := range u.KeyRefs </span><span class="cov8" title="1">{
                if k.KeyId == keyId </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package datastore

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "strconv"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/statements"
)

var ActiveDataStore DataStore

func CreateAssertion(ctx context.Context, statementUri references.HashUri, entityUri references.HashUri, kind string, confidence float64, privateKey *rsa.PrivateKey) *assertions.Assertion <span class="cov8" title="1">{
        assertion := assertions.NewAssertion(kind)
        assertion.Subject = statementUri.String()
        assertion.IssuedAt = jwt.NewNumericDate(time.Now())
        assertion.NotBefore = assertion.IssuedAt
        assertion.Confidence = float32(confidence)
        assertion.Issuer = entityUri.String()
        assertion.SetSummary(assertions.SummariseAssertion(ctx, assertion, nil, ActiveDataStore))
        assertion.MakeJwt(privateKey)
        ActiveDataStore.Store(ctx, &amp;assertion)

        CreateReferences(ctx, &amp;assertion)

        return &amp;assertion
}</span>

func CreateReferences(ctx context.Context, target references.Referenceable) <span class="cov8" title="1">{
        for _, uri := range target.References() </span><span class="cov8" title="1">{
                CreateReferenceWithSummary(ctx, uri, target.Uri())
        }</span>
}

// Creates a reference including a summary and stores it in the active datastore.
func CreateReferenceWithSummary(ctx context.Context, source references.HashUri, target references.HashUri) <span class="cov8" title="1">{
        ref := references.Reference{
                Source: source,
                Target: target,
        }
        MakeSummary(ctx, nil, &amp;ref, ActiveDataStore)
        ActiveDataStore.StoreRef(ctx, ref)
}</span>

func CreateStatementAndAssertion(ctx context.Context, content string, entityUri references.HashUri, kind string, confidence float64) (*assertions.Assertion, error) <span class="cov8" title="1">{
        log.DebugfX(ctx, "Creating statement and assertion")

        b64key, err := ActiveDataStore.FetchKey(entityUri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">privateKey := entities.PrivateKeyFromString(b64key)
        entity, err := ActiveDataStore.FetchEntity(ctx, entityUri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create and save the statement
        <span class="cov8" title="1">statement := statements.NewStatement(content)
        ActiveDataStore.Store(ctx, statement)

        log.DebugfX(ctx, "Statement created")

        // Create and save an assertion by the default entity that the statement is probably true
        assertion := CreateAssertion(ctx, statement.Uri(), entity.Uri(), "IsTrue", confidence, privateKey)

        log.DebugfX(ctx, "Assertion created")

        return assertion, nil</span>
}

func MakeSummary(ctx context.Context, target *references.Referenceable, ref *references.Reference, resolver assertions.Resolver) <span class="cov8" title="1">{
        switch ref.Source.Kind() </span>{
        case "statement":<span class="cov8" title="1">
                statement, _ := resolver.FetchStatement(ctx, ref.Source)
                ref.Summary = statement.Summary()</span>
        case "entity":<span class="cov8" title="1">
                entity, _ := ActiveDataStore.FetchEntity(ctx, ref.Source)
                ref.Summary = entity.Summary()</span>
        case "document":<span class="cov0" title="0">
                doc, _ := resolver.FetchDocument(ctx, ref.Source)
                ref.Summary = doc.Summary()</span>
        case "assertion":<span class="cov8" title="1">
                var assertion assertions.Assertion
                if target != nil &amp;&amp; (*target).Uri().Equals(ref.Source) </span><span class="cov8" title="1">{
                        assertion = *((*target).(*assertions.Assertion))
                }</span> else<span class="cov0" title="0"> {
                        assertion, _ = resolver.FetchAssertion(ctx, ref.Source)
                }</span>
                <span class="cov8" title="1">summary := assertions.SummariseAssertion(ctx, assertion, target, resolver)
                ref.Summary = summary</span>
        default:<span class="cov0" title="0">
                ref.Summary = "Unknown " + ref.Source.Kind()</span>
        }
}

// Creates a new Statement and stores it in the active datastore.
func CreateStatement(ctx context.Context, content string) references.HashUri <span class="cov0" title="0">{
        statement := statements.NewStatement(content)
        ActiveDataStore.Store(ctx, statement)
        return statement.Uri()
}</span>

// Creates a new Entity with a private key and stores both in the active
func CreateEntityWithKey(ctx context.Context, commonName string) references.HashUri <span class="cov8" title="1">{
        privateKey, _ := rsa.GenerateKey(rand.Reader, 2048)
        entity := entities.Entity{CommonName: commonName}
        entity.MakeCertificate(privateKey)

        ActiveDataStore.Store(ctx, &amp;entity)

        ActiveDataStore.StoreKey(entity.Uri(), entities.PrivateKeyToString(privateKey))

        return entity.Uri()
}</span>

func CreateDocumentAndAssertions(ctx context.Context, content string, entityUri references.HashUri) (*docs.Document, error) <span class="cov8" title="1">{
        entity, err := ActiveDataStore.FetchEntity(ctx, entityUri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">doc, _ := docs.MakeDocument(content)

        author := &amp;doc.Metadata.Author
        if author.Entity == "" </span><span class="cov8" title="1">{
                log.DebugfX(ctx, "Setting document author to %s", entity.CommonName)
                author.Entity = entity.Uri().String()
                author.Name = entity.CommonName
        }</span>

        <span class="cov8" title="1">for i := range doc.Sections </span><span class="cov8" title="1">{
                for j := range doc.Sections[i].Paragraphs </span><span class="cov8" title="1">{
                        for k := range doc.Sections[i].Paragraphs[j].Spans </span><span class="cov8" title="1">{
                                span := &amp;doc.Sections[i].Paragraphs[j].Spans[k]
                                if span.Assertion != "" &amp;&amp; !strings.HasPrefix(span.Assertion, "hash://") </span><span class="cov8" title="1">{
                                        parts := strings.Split(span.Assertion, " ")
                                        assertionType := parts[0]
                                        confidence, _ := strconv.ParseFloat(parts[1], 32)

                                        assertion, _ := CreateStatementAndAssertion(ctx, span.Body, entityUri, assertionType, confidence)

                                        span.Assertion = assertion.Uri().String()
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">doc.UpdateContent()

        ActiveDataStore.Store(ctx, doc)

        for _, uri := range doc.References() </span><span class="cov8" title="1">{
                ref := references.Reference{
                        Source:  doc.Uri(),
                        Target:  uri,
                        Summary: doc.Summary(),
                }
                ActiveDataStore.StoreRef(ctx, ref)
        }</span>

        <span class="cov8" title="1">return doc, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package datastore

import (
        "context"
        "strings"

        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        "silvatek.uk/trustedassertions/internal/logging"
        refs "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/statements"
)

type DataStore interface {
        Name() string
        AutoInit() bool

        Fetch(ctx context.Context, uri refs.HashUri) (refs.Referenceable, error)
        FetchStatement(ctx context.Context, key refs.HashUri) (statements.Statement, error)
        FetchEntity(ctx context.Context, key refs.HashUri) (entities.Entity, error)
        FetchAssertion(ctx context.Context, key refs.HashUri) (assertions.Assertion, error)
        FetchDocument(ctx context.Context, key refs.HashUri) (docs.Document, error)
        Store(ctx context.Context, value refs.Referenceable)
        StoreRaw(uri refs.HashUri, content string)

        FetchRefs(ctx context.Context, key refs.HashUri) ([]refs.Reference, error)
        StoreRef(ctx context.Context, reference refs.Reference)

        StoreKey(entityUri refs.HashUri, key string)
        StoreUser(ctx context.Context, user auth.User)
        StoreRegistration(ctx context.Context, reg auth.Registration) error

        FetchKey(entityUri refs.HashUri) (string, error)
        FetchUser(ctx context.Context, id string) (auth.User, error)
        FetchRegistration(ctx context.Context, code string) (auth.Registration, error)

        Search(ctx context.Context, query string) ([]SearchResult, error)

        Reindex()
}

type DbRecord struct {
        Uri         string   `json:"uri" firestore:"uri"`
        Content     string   `json:"content" firestore:"content"`
        DataType    string   `json:"datatype" firestore:"datatype"`
        Summary     string   `json:"summary" firestore:"summary"`
        Updated     string   `json:"updated" firestore:"updated"`
        SearchWords []string `json:"words" firestore:"words"`
}

type SearchResult struct {
        Uri       refs.HashUri
        Content   string
        Relevance float32
}

type KeyNotFoundError struct {
}

var log = logging.GetLogger("datastore")

func (e *KeyNotFoundError) Error() string <span class="cov0" title="0">{
        return "Key not found"
}</span>

func summarise(uri refs.HashUri, content string) string <span class="cov8" title="1">{
        kind := strings.ToLower(uri.Kind())
        switch kind </span>{
        case "statement":<span class="cov8" title="1">
                return leftChars(content, 100)</span>
        case "entity":<span class="cov0" title="0">
                entity := entities.ParseCertificate(content)
                return entity.CommonName</span>
        case "document":<span class="cov0" title="0">
                doc, _ := docs.MakeDocument(content)
                return doc.Summary()</span>
        default:<span class="cov0" title="0">
                return content</span>
        }
}

func leftChars(text string, maxChars int) string <span class="cov8" title="1">{
        if len(text) &gt; maxChars </span><span class="cov0" title="0">{
                return text[0 : maxChars-1]
        }</span> else<span class="cov8" title="1"> {
                return text
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package datastore

import (
        "context"
        "encoding/json"
        "math/big"
        "os"
        "strconv"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        "google.golang.org/api/iterator"
        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        ref "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/search"
        "silvatek.uk/trustedassertions/internal/statements"
)

type FireStore struct {
        projectId    string
        databaseName string
}

const MainCollection = "Primary"
const KeyCollection = "Keys"
const UserCollection = "Users"
const RegistrationCollection = "Registration"

var EmptyRefs = []ref.HashUri{}

var client *firestore.Client

func InitFireStore(ctx context.Context) <span class="cov0" title="0">{
        datastore := &amp;FireStore{
                projectId:    os.Getenv("GCLOUD_PROJECT"),
                databaseName: os.Getenv("FIRESTORE_DB_NAME"),
        }
        log.InfofX(ctx, "Initialising FireStore: %s / %s", datastore.projectId, datastore.databaseName)
        ActiveDataStore = datastore
}</span>

func (fs *FireStore) Name() string <span class="cov0" title="0">{
        return "FireStore"
}</span>

func (fs *FireStore) AutoInit() bool <span class="cov0" title="0">{
        return false
}</span>

func (fs *FireStore) client(ctx context.Context) *firestore.Client <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                newClient, err := firestore.NewClientWithDatabase(ctx, fs.projectId, fs.databaseName)
                if err != nil </span><span class="cov0" title="0">{
                        log.ErrorfX(ctx, "Error connecting to database: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        client = newClient
                        log.DebugfX(ctx, "Connected to Firestore database: %v", client)
                }</span>
        }
        <span class="cov0" title="0">return client</span>
}

func (fs *FireStore) store(collection string, id string, data map[string]interface{}) <span class="cov0" title="0">{
        ctx := context.TODO()
        client := fs.client(ctx)
        result, err := client.Collection(collection).Doc(id).Set(ctx, data)

        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error writing value: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.DebugfX(ctx, "Written: %s %v", id, result)
        }</span>
}

func rawDataMap(uri ref.HashUri, content string, summary string, searchText string) map[string]interface{} <span class="cov8" title="1">{
        data := make(map[string]interface{})

        data["uri"] = uri.String()
        data["content"] = content
        data["datatype"] = uri.Kind()
        data["updated"] = time.Now().Format(time.RFC3339)

        if summary != "" </span><span class="cov8" title="1">{
                data["summary"] = summary
        }</span>
        <span class="cov8" title="1">if searchText != "" </span><span class="cov8" title="1">{
                data["words"] = search.SearchWords(searchText)
        }</span>

        <span class="cov8" title="1">return data</span>
}

func contentDataMap(value ref.Referenceable) map[string]interface{} <span class="cov8" title="1">{
        uri := value.Uri()
        if value.Type() != "" &amp;&amp; !uri.HasType() </span><span class="cov0" title="0">{
                uri = uri.WithType(value.Type())
        }</span>
        <span class="cov8" title="1">data := rawDataMap(uri, value.Content(), value.Summary(), value.TextContent())
        return data</span>
}

func (fs *FireStore) StoreRecord(ctx context.Context, uri ref.HashUri, rec DbRecord) <span class="cov0" title="0">{
        client := fs.client(ctx)

        result, err := client.Collection(MainCollection).Doc(uri.Escaped()).Set(ctx, rec)

        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error writing value: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.DebugfX(ctx, "Written: %s %v", uri.Escaped(), result)
        }</span>
}

func (fs *FireStore) StoreRaw(uri ref.HashUri, content string) <span class="cov0" title="0">{
        log.Debugf("Writing to datastore: %s", uri)

        fs.store(MainCollection, uri.Escaped(), rawDataMap(uri, content, "", ""))
}</span>

func (fs *FireStore) Store(ctx context.Context, value ref.Referenceable) <span class="cov0" title="0">{
        log.DebugfX(ctx, "Writing to datastore: %s", value.Uri())

        uri := value.Uri()
        if value.Type() != "" &amp;&amp; !uri.HasType() </span><span class="cov0" title="0">{
                uri = uri.WithType(value.Type())
        }</span>

        <span class="cov0" title="0">rec := DbRecord{
                Uri:         uri.String(),
                Content:     value.Content(),
                DataType:    value.Type(),
                Summary:     value.Summary(),
                Updated:     time.Now().Format(time.RFC3339),
                SearchWords: search.SearchWords(value.TextContent()),
        }
        fs.StoreRecord(ctx, uri, rec)</span>
}

// func (fs *FireStore) storeRefs(ctx context.Context, refs []Reference) {
//         for _, ref := range refs {
//                 fs.StoreRef(ctx, ref)
//         }
// }

func (fs *FireStore) StoreKey(entityUri ref.HashUri, key string) <span class="cov0" title="0">{
        data := make(map[string]interface{})
        data["entity"] = entityUri.Unadorned()
        data["encoding"] = "base64"
        data["key"] = key

        fs.store(KeyCollection, entityUri.Escaped(), data)
}</span>

func (fs *FireStore) StoreRef(ctx context.Context, reference ref.Reference) <span class="cov0" title="0">{
        client := fs.client(ctx)

        data := make(map[string]string)
        data["source"] = reference.Source.String()
        data["target"] = reference.Target.String()
        data["summary"] = reference.Summary
        data["updated"] = time.Now().Format(time.RFC3339)

        refs := client.Collection(MainCollection).Doc(reference.Target.Escaped()).Collection("refs")
        refs.Doc(reference.Source.Escaped()).Set(ctx, data)

        log.DebugfX(ctx, "Stored reference from %s to %s", reference.Source.String(), reference.Target.String())
}</span>

func (fs *FireStore) fetch(ctx context.Context, uri ref.HashUri) (*DbRecord, error) <span class="cov0" title="0">{
        client := fs.client(ctx)

        doc, err := client.Collection(MainCollection).Doc(uri.Escaped()).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error reading value: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> {
                record := DbRecord{}
                doc.DataTo(&amp;record)
                return &amp;record, nil
        }</span>
}

func (fs *FireStore) Fetch(ctx context.Context, uri ref.HashUri) (ref.Referenceable, error) <span class="cov0" title="0">{
        record, err := fs.fetch(ctx, uri)
        if err != nil </span><span class="cov0" title="0">{
                return ref.REF_ERROR, err
        }</span>

        <span class="cov0" title="0">item := assertions.NewReferenceable(record.DataType)
        item.ParseContent(record.Content)

        return item, nil</span>
}

func (fs *FireStore) FetchStatement(ctx context.Context, uri ref.HashUri) (statements.Statement, error) <span class="cov0" title="0">{
        record, err := fs.fetch(ctx, uri)

        log.DebugfX(ctx, "Fetched statement %s", uri)

        if err != nil </span><span class="cov0" title="0">{
                return *statements.NewStatement("{bad record}"), err
        }</span> else<span class="cov0" title="0"> {
                return *statements.NewStatement(record.Content), nil
        }</span>
}

func (fs *FireStore) FetchEntity(ctx context.Context, uri ref.HashUri) (entities.Entity, error) <span class="cov0" title="0">{
        record, err := fs.fetch(ctx, uri)

        log.DebugfX(ctx, "Fetched entity %s", uri)

        if err != nil </span><span class="cov0" title="0">{
                return entities.NewEntity("{bad record}", *big.NewInt(0)), err
        }</span> else<span class="cov0" title="0"> {
                return entities.ParseCertificate(record.Content), nil
        }</span>
}

func (fs *FireStore) FetchAssertion(ctx context.Context, uri ref.HashUri) (assertions.Assertion, error) <span class="cov0" title="0">{
        record, err := fs.fetch(ctx, uri)

        if err != nil </span><span class="cov0" title="0">{
                return assertions.NewAssertion("{bad record}"), err
        }</span>

        <span class="cov0" title="0">log.DebugfX(ctx, "Fetched assertion %s", uri)

        assertion, err := assertions.ParseAssertionJwt(record.Content)
        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error parsing JWT: %v", err)
                return assertions.NewAssertion("{bad record}"), err
        }</span>
        <span class="cov0" title="0">return assertion, nil</span>
}

func (fs *FireStore) FetchDocument(ctx context.Context, uri ref.HashUri) (docs.Document, error) <span class="cov0" title="0">{
        record, _ := fs.fetch(ctx, uri)

        log.DebugfX(ctx, "Fetched document %s", uri)

        doc, _ := docs.MakeDocument(record.Content)

        return *doc, nil
}</span>

// func (fs *FireStore) FetchMany(ctx context.Context, keys []ref.HashUri) ([]ref.Referenceable, error) {
//         log.DebugfX(ctx, "Fetching %d keys", len(keys))
//         results := make([]ref.Referenceable, 0)

//         refs := make([]*firestore.DocumentRef, len(keys))
//         for n, key := range keys {
//                 refs[n] = client.Collection(MainCollection).Doc(key.Escaped())
//         }

//         records, err := fs.query(ctx, firestore.DocumentID, "in", refs)
//         if err != nil {
//                 return results, err
//         }
//         for _, record := range records {
//                 value := assertions.Newref.Referenceable(record.DataType)
//                 value.ParseContent(record.Content)
//                 results = append(results, value)
//         }

//         log.DebugfX(ctx, "Fetched %d values", len(results))

//         return results, nil
// }

type KeyRecord struct {
        Entity   string `json:"entity"`
        Key      string `json:"key"`
        Encoding string `json:"encoding"`
}

func (fs *FireStore) FetchKey(entityUri ref.HashUri) (string, error) <span class="cov0" title="0">{
        ctx := context.TODO()
        client := fs.client(ctx)

        doc, err := client.Collection(KeyCollection).Doc(entityUri.Escaped()).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error reading value: %v", err)
                return "", err
        }</span> else<span class="cov0" title="0"> {
                record := KeyRecord{}
                doc.DataTo(&amp;record)
                return record.Key, nil
        }</span>
}

type DbReference struct {
        Source  string `json:"source"`
        Target  string `json:"target"`
        Type    string `json:"type"`
        Summary string `json:"summary"`
}

func (fs *FireStore) FetchRefs(ctx context.Context, uri ref.HashUri) ([]ref.Reference, error) <span class="cov0" title="0">{
        log.DebugfX(ctx, "Fetching references for %s", uri.String())

        client := fs.client(ctx)
        results := make([]ref.Reference, 0)

        refs := client.Collection(MainCollection).Doc(uri.Escaped()).Collection("refs").Documents(ctx)
        for </span><span class="cov0" title="0">{
                doc, err := refs.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">record := DbReference{}
                doc.DataTo(&amp;record)

                reference := ref.Reference{
                        Source:  ref.UriFromString(record.Source),
                        Target:  ref.UriFromString(record.Target),
                        Summary: record.Summary,
                }

                results = append(results, reference)</span>
        }

        <span class="cov0" title="0">log.DebugfX(ctx, "Found %d references", len(results))
        return results, nil</span>
}

func (fs *FireStore) StoreUser(ctx context.Context, user auth.User) <span class="cov0" title="0">{
        client := fs.client(ctx)

        client.Collection(UserCollection).Doc(user.Id).Set(ctx, user)

        log.Debugf("Stored user %s", user.Id)
}</span>

func (fs *FireStore) FetchUser(ctx context.Context, id string) (auth.User, error) <span class="cov0" title="0">{
        client := fs.client(ctx)

        user := auth.User{}

        doc, err := client.Collection(UserCollection).Doc(id).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>
        <span class="cov0" title="0">doc.DataTo(&amp;user)

        return user, nil</span>
}

// Thin wrapper around firestore.DocumentIterator that allows for mocking.
type DocFetcher struct {
        testData  []DbRecord
        testIndex int
        iterator  *firestore.DocumentIterator
}

func (df *DocFetcher) Next() *DbRecord <span class="cov8" title="1">{
        if df.testData != nil </span><span class="cov8" title="1">{
                if df.testIndex &gt;= len(df.testData) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">next := df.testData[df.testIndex]
                df.testIndex++
                return &amp;next</span>
        }

        <span class="cov0" title="0">doc, err := df.iterator.Next()
        if err == iterator.Done </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">record := DbRecord{}
        doc.DataTo(&amp;record)
        return &amp;record</span>
}

func (fs *FireStore) Search(ctx context.Context, query string) ([]SearchResult, error) <span class="cov0" title="0">{
        queryWords := search.SearchWords(query)

        results := make([]SearchResult, 0)

        records, _ := fs.query(ctx, "words", "array-contains-any", queryWords)
        for _, record := range records </span><span class="cov0" title="0">{
                uri := ref.UriFromString(record.Uri)
                if !uri.HasType() </span><span class="cov0" title="0">{
                        uri = uri.WithType(record.DataType)
                }</span>

                <span class="cov0" title="0">result := SearchResult{
                        Uri:       uri,
                        Content:   record.Summary,
                        Relevance: 0.8,
                }
                results = append(results, result)</span>
        }

        <span class="cov0" title="0">log.DebugfX(ctx, "Search for `%s` found %d matches", query, len(results))

        return results, nil</span>
}

func (fs *FireStore) query(ctx context.Context, fieldName string, operator string, values interface{}) ([]DbRecord, error) <span class="cov0" title="0">{
        client := fs.client(ctx)

        results := make([]DbRecord, 0)

        query := client.Collection(MainCollection).Where(fieldName, operator, values).WithRunOptions(firestore.ExplainOptions{Analyze: true})
        docs := query.Documents(ctx)
        for </span><span class="cov0" title="0">{
                doc, err := docs.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return results, err
                }</span>

                <span class="cov0" title="0">record := DbRecord{}
                doc.DataTo(&amp;record)
                results = append(results, record)</span>
        }
        <span class="cov0" title="0">plan, err := docs.ExplainMetrics()
        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error in query explain: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.DebugfX(ctx, "Plan summary: %s", explainString(plan))
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func explainString(plan *firestore.ExplainMetrics) string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("Execution duration=")
        sb.WriteString(plan.ExecutionStats.ExecutionDuration.String())
        sb.WriteString("\nRead operations=")
        sb.WriteString(strconv.Itoa(int(plan.ExecutionStats.ReadOperations)))
        sb.WriteString("\nIndexes used=")
        sb.WriteString(strconv.Itoa(len(plan.PlanSummary.IndexesUsed)))
        sb.WriteString("\nJSON=")
        bytes, _ := json.Marshal(plan)
        sb.Write(bytes)

        return sb.String()
}</span>

func searchDocs(docs DocFetcher, query string) []SearchResult <span class="cov8" title="1">{
        results := make([]SearchResult, 0)
        for </span><span class="cov8" title="1">{
                record := docs.Next()
                if record == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if strings.ToLower(record.DataType) == "assertion" </span><span class="cov8" title="1">{
                        // Don't bother searching assertions as they don't have textual content
                        continue</span>
                }

                <span class="cov8" title="1">summary := record.Summary
                if summary == "" &amp;&amp; strings.ToLower(record.DataType) == "statement" </span><span class="cov8" title="1">{
                        summary = record.Content
                }</span> else<span class="cov8" title="1"> if summary == "" &amp;&amp; strings.ToLower(record.DataType) == "entity" </span><span class="cov0" title="0">{
                        summary = entities.ParseCertificate(record.Content).CommonName
                }</span>
                <span class="cov8" title="1">log.Debugf("Searching %s =&gt; %s", record.Uri, summary)

                if contentMatches(summary, query) </span><span class="cov8" title="1">{
                        uri := ref.UriFromString(record.Uri)
                        if !uri.HasType() </span><span class="cov8" title="1">{
                                uri = uri.WithType(assertions.GuessContentType(record.Content))
                        }</span>

                        <span class="cov8" title="1">result := SearchResult{
                                Uri:       uri,
                                Content:   summary,
                                Relevance: 0.8,
                        }

                        results = append(results, result)</span>
                }
        }
        <span class="cov8" title="1">return results</span>
}

func contentMatches(content string, query string) bool <span class="cov8" title="1">{
        return strings.Contains(strings.ToLower(content), strings.ToLower(query))
}</span>

type SearchData struct {
        Uri   string   `json:"uri"`
        Words []string `json:"words"`
}

func (fs *FireStore) Reindex() <span class="cov0" title="0">{
        log.Info("Reindexing...")
        ctx := context.TODO()
        client := fs.client(ctx)
        // defer client.Close()

        docs := client.Collection(MainCollection).Documents(ctx)
        for </span><span class="cov0" title="0">{
                doc, err := docs.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">record := DbRecord{}
                doc.DataTo(&amp;record)

                if record.DataType == "assertion" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">summary := record.Summary
                words := search.SearchWords(summary)

                doc.Ref.Update(ctx, []firestore.Update{
                        {
                                Path:  "words",
                                Value: words,
                        },
                })</span>

        }

        <span class="cov0" title="0">log.Info("Reindex complete.")</span>
}

func (fs *FireStore) StoreRegistration(ctx context.Context, reg auth.Registration) error <span class="cov0" title="0">{
        client := fs.client(ctx)

        _, err := client.Collection(RegistrationCollection).Doc(reg.Code).Set(ctx, reg)

        return err
}</span>

func (fs *FireStore) FetchRegistration(ctx context.Context, code string) (auth.Registration, error) <span class="cov0" title="0">{
        client := fs.client(ctx)

        var reg auth.Registration

        doc, err := client.Collection(RegistrationCollection).Doc(code).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return reg, err
        }</span>

        <span class="cov0" title="0">doc.DataTo(&amp;reg)

        return reg, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package datastore

import (
        "context"
        "errors"
        "strings"

        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        . "silvatek.uk/trustedassertions/internal/references"
        refs "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/statements"
)

type InMemoryDataStore struct {
        data  map[string]DbRecord
        keys  map[string]string
        refs  map[string][]Reference
        users map[string]auth.User
        krefs map[string]auth.KeyRef
        regs  map[string]auth.Registration
}

func NewInMemoryDataStore() DataStore <span class="cov8" title="1">{
        datastore := InMemoryDataStore{}
        datastore.data = make(map[string]DbRecord)
        datastore.keys = make(map[string]string)
        datastore.refs = make(map[string][]Reference)
        datastore.users = make(map[string]auth.User)
        datastore.krefs = make(map[string]auth.KeyRef)
        datastore.regs = make(map[string]auth.Registration)
        return &amp;datastore
}</span>

func InitInMemoryDataStore() <span class="cov8" title="1">{
        ActiveDataStore = NewInMemoryDataStore()
}</span>

func (ds *InMemoryDataStore) Name() string <span class="cov8" title="1">{
        return "InMemoryDataStore"
}</span>

func (ds *InMemoryDataStore) AutoInit() bool <span class="cov8" title="1">{
        return true
}</span>

func (ds *InMemoryDataStore) StoreRecord(uri HashUri, rec DbRecord) <span class="cov8" title="1">{
        log.Debugf("Storing %s", uri)
        ds.data[uri.Escaped()] = rec
}</span>

func (ds *InMemoryDataStore) StoreRaw(uri HashUri, content string) <span class="cov0" title="0">{
        ds.StoreRecord(uri, DbRecord{Uri: uri.String(), Content: content})
}</span>

func (ds *InMemoryDataStore) Store(ctx context.Context, value Referenceable) <span class="cov8" title="1">{
        ds.StoreRecord(value.Uri(), DbRecord{Uri: value.Uri().String(), DataType: value.Type(), Content: value.Content()})
}</span>

func (ds *InMemoryDataStore) StoreKey(entityUri HashUri, key string) <span class="cov8" title="1">{
        ds.keys[entityUri.Escaped()] = key
}</span>

func (ds *InMemoryDataStore) StoreRef(ctx context.Context, reference refs.Reference) <span class="cov8" title="1">{
        targetKey := reference.Target.Escaped()
        refs, ok := ds.refs[targetKey]
        if !ok </span><span class="cov8" title="1">{
                refs = make([]Reference, 0)
        }</span>
        <span class="cov8" title="1">refs = append(refs, reference)
        ds.refs[targetKey] = refs</span>
}

func (ds *InMemoryDataStore) FetchInto(key HashUri, item Referenceable) error <span class="cov8" title="1">{
        record, ok := ds.data[key.Escaped()]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("URI not found: " + key.String())
        }</span>
        <span class="cov8" title="1">return item.ParseContent(record.Content)</span>
}

func (ds *InMemoryDataStore) Fetch(ctx context.Context, key HashUri) (Referenceable, error) <span class="cov0" title="0">{
        record, ok := ds.data[key.Escaped()]
        if !ok </span><span class="cov0" title="0">{
                return REF_ERROR, errors.New("URI not found: " + key.String())
        }</span>

        <span class="cov0" title="0">item := assertions.NewReferenceable(record.DataType)
        item.ParseContent(record.Content)

        return item, nil</span>
}

func (ds *InMemoryDataStore) FetchStatement(ctx context.Context, key HashUri) (statements.Statement, error) <span class="cov8" title="1">{
        var statement statements.Statement
        return statement, ds.FetchInto(key, &amp;statement)
}</span>

func (ds *InMemoryDataStore) FetchEntity(ctx context.Context, key HashUri) (entities.Entity, error) <span class="cov8" title="1">{
        var entity entities.Entity
        return entity, ds.FetchInto(key, &amp;entity)
}</span>

func (ds *InMemoryDataStore) FetchAssertion(ctx context.Context, key HashUri) (assertions.Assertion, error) <span class="cov8" title="1">{
        var assertion assertions.Assertion
        return assertion, ds.FetchInto(key, &amp;assertion)
}</span>

func (ds *InMemoryDataStore) FetchDocument(ctx context.Context, key HashUri) (docs.Document, error) <span class="cov8" title="1">{
        var doc docs.Document
        return doc, ds.FetchInto(key, &amp;doc)
}</span>

func (ds *InMemoryDataStore) FetchKey(entityUri HashUri) (string, error) <span class="cov8" title="1">{
        key, ok := ds.keys[entityUri.Escaped()]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("entity id not found " + entityUri.String())
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

func (ds *InMemoryDataStore) FetchRefs(ctx context.Context, key HashUri) ([]Reference, error) <span class="cov8" title="1">{
        refs := make([]Reference, 0)
        result, ok := ds.refs[key.Escaped()]
        if !ok </span><span class="cov0" title="0">{
                return refs, nil
        }</span>
        // for _, ref := range result {
        //         refs = append(refs, ref)
        // }
        <span class="cov8" title="1">refs = append(refs, result...)
        return refs, nil</span>
}

func (ds *InMemoryDataStore) StoreUser(ctx context.Context, user auth.User) <span class="cov8" title="1">{
        ds.users[user.Id] = user
        if user.KeyRefs != nil </span><span class="cov8" title="1">{
                for _, ref := range user.KeyRefs </span><span class="cov8" title="1">{
                        ds.krefs[ref.UserId+" "+ref.KeyId] = ref
                }</span>
        }
}

func (ds *InMemoryDataStore) FetchUser(ctx context.Context, id string) (auth.User, error) <span class="cov8" title="1">{
        user, ok := ds.users[id]
        if !ok </span><span class="cov0" title="0">{
                return auth.User{}, errors.New("User not found with id " + id)
        }</span>
        <span class="cov8" title="1">user.KeyRefs = make([]auth.KeyRef, 0)
        for key, value := range ds.krefs </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, id) </span><span class="cov8" title="1">{
                        user.KeyRefs = append(user.KeyRefs, value)
                }</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}

func (ds *InMemoryDataStore) Search(ctx context.Context, query string) ([]SearchResult, error) <span class="cov8" title="1">{
        results := make([]SearchResult, 0)
        query = strings.ToLower(query)
        for key, value := range ds.data </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(value.Content), query) </span><span class="cov8" title="1">{
                        uri := UnescapeUri(key, assertions.GuessContentType(value.Content))
                        result := SearchResult{
                                Uri:       uri,
                                Content:   summarise(uri, value.Content),
                                Relevance: 0.8,
                        }
                        results = append(results, result)
                }</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}

func (ds *InMemoryDataStore) Reindex() {<span class="cov0" title="0">
        // NO-OP
}</span>

func (ds *InMemoryDataStore) StoreRegistration(ctx context.Context, reg auth.Registration) error <span class="cov0" title="0">{
        ds.regs[reg.Code] = reg
        return nil
}</span>

func (ds *InMemoryDataStore) FetchRegistration(ctx context.Context, code string) (auth.Registration, error) <span class="cov0" title="0">{
        reg, ok := ds.regs[code]
        if !ok </span><span class="cov0" title="0">{
                return auth.Registration{}, errors.New("Registration not found with code " + code)
        }</span>
        <span class="cov0" title="0">return reg, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package docs

import (
        "encoding/xml"
        "os"
        "strings"

        refs "silvatek.uk/trustedassertions/internal/references"
)

type Document struct {
        uri      refs.HashUri `xml:"-"`
        text     string       `xml:"-"`
        XMLName  xml.Name     `xml:"document"`
        Metadata MetaData     `xml:"metadata"`
        Sections []Section    `xml:"section"`
}

type MetaData struct {
        XMLName  xml.Name `xml:"metadata"`
        Author   Author   `xml:"author,omitempty"`
        Title    string   `xml:"title,omitempty"`
        Keywords string   `xml:"keywords,omitempty"`
}

type Author struct {
        XMLName xml.Name `xml:"author"`
        Entity  string   `xml:"entity,attr,omitempty"`
        Name    string   `xml:",chardata"`
}

type Section struct {
        XMLName    xml.Name    `xml:"section"`
        Attrs      []xml.Attr  `xml:",any,attr"`
        Title      *Title      `xml:"title"`
        Paragraphs []Paragraph `xml:"paragraph"`
}

type Title struct {
        XMLName xml.Name `xml:"title"`
        Text    string   `xml:",chardata"`
}

type Paragraph struct {
        XMLName xml.Name   `xml:"paragraph"`
        Attrs   []xml.Attr `xml:",any,attr"`
        Spans   []Span     `xml:"span"`
}

type Span struct {
        XMLName   xml.Name `xml:"span"`
        Statement string   `xml:"statement,attr,omitempty"`
        Assertion string   `xml:"assertion,attr,omitempty"`
        Body      string   `xml:",chardata"`
}

func LoadDocument(filename string) (*Document, error) <span class="cov8" title="1">{
        buf, err := os.ReadFile(filename)

        if err == nil </span><span class="cov8" title="1">{
                return MakeDocument(string(buf))
        }</span> else<span class="cov0" title="0"> {
                return nil, err
        }</span>
}

func MakeDocument(content string) (*Document, error) <span class="cov8" title="1">{
        var doc Document

        doc.text = content
        err := xml.Unmarshal([]byte(content), &amp;doc)

        return &amp;doc, err
}</span>

func (d *Document) ParseContent(content string) error <span class="cov0" title="0">{
        d.text = content

        return xml.Unmarshal([]byte(content), d)
}</span>

var DefaultDocumentUri refs.HashUri

func (d *Document) Uri() refs.HashUri <span class="cov0" title="0">{
        if d.uri.IsEmpty() </span><span class="cov0" title="0">{
                // hash := sha256.New()
                // hash.Write([]byte(d.text))
                // d.uri = refs.MakeUriB(hash.Sum(nil), "document")
                d.uri = refs.UriFor(d)
        }</span>
        <span class="cov0" title="0">return d.uri</span>
}

func (d Document) Type() string <span class="cov0" title="0">{
        return "Document"
}</span>

func (d Document) Content() string <span class="cov0" title="0">{
        return d.text
}</span>

func (d Document) Summary() string <span class="cov0" title="0">{
        return d.Metadata.Title
}</span>

func (d Document) References() []refs.HashUri <span class="cov0" title="0">{
        references := make([]refs.HashUri, 0)
        if d.Metadata.Author.Entity != "" </span><span class="cov0" title="0">{
                references = append(references, refs.UriFromString(d.Metadata.Author.Entity))
        }</span>
        <span class="cov0" title="0">for _, span := range d.allAssertions() </span><span class="cov0" title="0">{
                references = append(references, refs.UriFromString(span.Assertion))
        }</span>
        <span class="cov0" title="0">return references</span>
}

func (d *Document) allAssertions() []Span <span class="cov0" title="0">{
        assertions := make([]Span, 0)

        for _, sect := range d.Sections </span><span class="cov0" title="0">{
                for _, para := range sect.Paragraphs </span><span class="cov0" title="0">{
                        for _, span := range para.Spans </span><span class="cov0" title="0">{
                                if span.Assertion != "" </span><span class="cov0" title="0">{
                                        assertions = append(assertions, span)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return assertions</span>
}

func (doc *Document) ToHtml() string <span class="cov8" title="1">{
        var html string

        for _, sect := range doc.Sections </span><span class="cov8" title="1">{
                html = html + "\n&lt;div class='docsection'&gt;"
                if sect.Title != nil </span><span class="cov8" title="1">{
                        html = html + "\n   &lt;h1&gt;" + sect.Title.Text + "&lt;/h1&gt;"
                }</span>
                <span class="cov8" title="1">for _, para := range sect.Paragraphs </span><span class="cov8" title="1">{
                        html = html + "\n   &lt;div class='docpara'&gt;\n      "
                        for _, span := range para.Spans </span><span class="cov8" title="1">{
                                if span.Assertion != "" </span><span class="cov8" title="1">{
                                        uri := refs.UriFromString(span.Assertion)
                                        html = html + "&lt;a href='" + uri.WebPath() + "'&gt;" + span.Body + "&lt;/a&gt;"
                                }</span> else<span class="cov8" title="1"> if span.Statement != "" </span><span class="cov0" title="0">{
                                        uri := refs.UriFromString(span.Statement)
                                        html = html + "&lt;a href='" + uri.WebPath() + "'&gt;" + span.Body + "&lt;/a&gt;"
                                }</span> else<span class="cov8" title="1"> {
                                        html = html + "&lt;span&gt;" + span.Body + "&lt;/span&gt;"
                                }</span>
                        }
                        <span class="cov8" title="1">html = html + "\n   &lt;/div&gt;"</span>
                }
                <span class="cov8" title="1">html = html + "\n&lt;/div&gt;"</span>
        }
        <span class="cov8" title="1">return html</span>
}

func (doc *Document) TextContent() string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(doc.Metadata.Title)
        sb.WriteString(" ")
        sb.WriteString(doc.Metadata.Author.Name)
        sb.WriteString(" ")
        sb.WriteString(doc.Metadata.Keywords)
        sb.WriteString(" ")

        for _, sect := range doc.Sections </span><span class="cov8" title="1">{
                if sect.Title != nil </span><span class="cov8" title="1">{
                        sb.WriteString(sect.Title.Text)
                        sb.WriteString(" ")
                }</span>
                <span class="cov8" title="1">for _, para := range sect.Paragraphs </span><span class="cov8" title="1">{
                        for _, span := range para.Spans </span><span class="cov8" title="1">{
                                sb.WriteString(span.Body)
                                sb.WriteString(" ")
                        }</span>
                }
        }
        <span class="cov8" title="1">return sb.String()</span>
}

func (doc *Document) ToXml() string <span class="cov0" title="0">{
        data, _ := xml.MarshalIndent(doc, "", "  ")
        return string(data)
}</span>

// Replaces the context text with an updated XML version.
func (doc *Document) UpdateContent() <span class="cov0" title="0">{
        doc.text = doc.ToXml()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package entities

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/base64"
        "encoding/pem"
        "math/big"
        "time"

        "silvatek.uk/trustedassertions/internal/logging"
        refs "silvatek.uk/trustedassertions/internal/references"
)

type Entity struct {
        SerialNum   big.Int
        CommonName  string         `json:"name"`
        Certificate string         `json:"cert"`
        uri         refs.HashUri   `json:"-"`
        Issued      time.Time      `json:"-"`
        PublicKey   *rsa.PublicKey `json:"-"`
}

var log = logging.GetLogger("entities")

func NewEntity(commonName string, serialNum big.Int) Entity <span class="cov8" title="1">{
        return Entity{CommonName: commonName, SerialNum: serialNum, Issued: time.Now()}
}</span>

func randomSerialNum() big.Int <span class="cov8" title="1">{
        max := new(big.Int)
        max.Exp(big.NewInt(2), big.NewInt(130), nil).Sub(max, big.NewInt(1))

        serNum, _ := rand.Int(rand.Reader, max)

        return *serNum
}</span>

func (e *Entity) Uri() refs.HashUri <span class="cov8" title="1">{
        if e.uri.String() == "" </span><span class="cov8" title="1">{
                if e.Certificate == "" </span><span class="cov0" title="0">{
                        log.Errorf("Cannot make URI without certificate")
                        return refs.ERROR_URI
                }</span>
                <span class="cov8" title="1">e.uri = refs.UriFor(e)</span>
                // hash := sha256.New()
                // hash.Write([]byte(e.Certificate))
                // e.uri = MakeUriB(hash.Sum(nil), "entity")
        }
        <span class="cov8" title="1">return e.uri</span>
}

func (e *Entity) AssignSerialNum() <span class="cov8" title="1">{
        e.SerialNum = randomSerialNum()
}</span>

func (e *Entity) HasSerialNum() bool <span class="cov8" title="1">{
        return e.SerialNum.Int64() != 0
}</span>

func (e *Entity) Type() string <span class="cov8" title="1">{
        return "Entity"
}</span>

func (e *Entity) Content() string <span class="cov8" title="1">{
        return e.Certificate
}</span>

func (e *Entity) Summary() string <span class="cov8" title="1">{
        return e.CommonName
}</span>

func (e *Entity) TextContent() string <span class="cov0" title="0">{
        return e.CommonName
}</span>

func (e *Entity) References() []refs.HashUri <span class="cov0" title="0">{
        return []refs.HashUri{}
}</span>

func (e *Entity) MakeCertificate(privateKey *rsa.PrivateKey) <span class="cov8" title="1">{
        if !e.HasSerialNum() </span><span class="cov8" title="1">{
                e.AssignSerialNum()
        }</span>
        <span class="cov8" title="1">e.PublicKey = &amp;privateKey.PublicKey

        template := x509.Certificate{
                SerialNumber:          &amp;e.SerialNum,
                IsCA:                  true,
                KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature,
                Subject:               pkix.Name{CommonName: e.CommonName},
                SignatureAlgorithm:    x509.SHA256WithRSA,
                NotBefore:             e.Issued,
                NotAfter:              e.Issued.Add(time.Hour * 24 * 365 * 2),
                BasicConstraintsValid: true,
        }
        cert, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error creating entity certificate: %v", err)
                return
        }</span>
        <span class="cov8" title="1">b := pem.Block{Type: "CERTIFICATE", Bytes: cert}
        e.Certificate = string(pem.EncodeToMemory(&amp;b))</span>
}

func (e *Entity) ParseContent(content string) error <span class="cov0" title="0">{
        e.Certificate = content

        p, _ := pem.Decode([]byte(content))

        cert, err := x509.ParseCertificate(p.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> {
                e.SerialNum = *cert.SerialNumber
                e.CommonName = cert.Subject.CommonName
                e.PublicKey = cert.PublicKey.(*rsa.PublicKey)
                return nil
        }</span>
}

func ParseCertificate(content string) Entity <span class="cov8" title="1">{
        entity := NewEntity("{unknown}", *big.NewInt(0))

        entity.Certificate = content

        p, _ := pem.Decode([]byte(content))

        cert, err := x509.ParseCertificate(p.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error parsing X509 certificate: %v", err)
        }</span> else<span class="cov8" title="1"> {
                entity.SerialNum = *cert.SerialNumber
                entity.CommonName = cert.Subject.CommonName
                entity.PublicKey = cert.PublicKey.(*rsa.PublicKey)
        }</span>

        <span class="cov8" title="1">return entity</span>
}

func PrivateKeyToString(prvKey *rsa.PrivateKey) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(x509.MarshalPKCS1PrivateKey(prvKey))
}</span>

func PrivateKeyFromString(base64encoded string) *rsa.PrivateKey <span class="cov0" title="0">{
        bytes, _ := base64.StdEncoding.DecodeString(base64encoded)
        privateKey, err := x509.ParsePKCS1PrivateKey(bytes)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error decoding key")
        }</span>
        <span class="cov0" title="0">return privateKey</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package logging

import (
        "context"
        "fmt"
        "io"
        "os"
)

type Logger struct {
        Name       string
        Level      int
        Structured bool
        Writer     io.Writer
}

var loggers map[string]Logger = nil

func GetLogger(name string) Logger <span class="cov8" title="1">{
        if loggers == nil </span><span class="cov8" title="1">{
                loggers = make(map[string]Logger, 0)
        }</span>
        <span class="cov8" title="1">log, found := loggers[name]
        if !found </span><span class="cov8" title="1">{
                log = Logger{Name: name, Level: DEBUG, Structured: structuredLogging(), Writer: LogWriter}
                loggers[name] = log
        }</span>
        <span class="cov8" title="1">return log</span>
}

func structuredLogging() bool <span class="cov8" title="1">{
        return (os.Getenv("LOG_TYPE") == "structured") || (os.Getenv("GCLOUD_PROJECT") != "")
}</span>

func (log Logger) Print(args ...any) <span class="cov8" title="1">{
        text := ""
        for _, arg := range args </span><span class="cov8" title="1">{
                if len(text) &gt; 0 </span><span class="cov0" title="0">{
                        text += " "
                }</span>
                <span class="cov8" title="1">text += fmt.Sprintf("%v", arg)</span>
        }
        <span class="cov8" title="1">log.Info(text)</span>
}

func (log Logger) Println(args ...any) <span class="cov0" title="0">{
        log.Print(args...)
}</span>

func (log Logger) Printf(template string, args ...any) <span class="cov0" title="0">{
        log.Infof(template, args...)
}</span>

func (log Logger) DebugfX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        if log.Level &gt;= DEBUG </span><span class="cov8" title="1">{
                WriteNamedLog(ctx, log.Writer, log.Structured, log.Name, "DEBUG", text, args...)
        }</span>
}

func (log Logger) Debugf(text string, args ...interface{}) <span class="cov8" title="1">{
        log.DebugfX(context.Background(), text, args...)
}</span>

func (log Logger) Info(text string) <span class="cov8" title="1">{
        log.InfofX(context.Background(), text)
}</span>

func (log Logger) Infof(text string, args ...interface{}) <span class="cov8" title="1">{
        log.InfofX(context.Background(), text, args...)
}</span>

func (log Logger) InfofX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        if log.Level &lt;= INFO </span><span class="cov8" title="1">{
                WriteNamedLog(ctx, log.Writer, log.Structured, log.Name, "INFO ", text, args...)
        }</span>
}

func (log Logger) ErrorfX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        if log.Level &lt;= ERROR </span><span class="cov8" title="1">{
                WriteNamedLog(ctx, log.Writer, log.Structured, log.Name, "ERROR", text, args...)
        }</span>
}

func (log Logger) Errorf(text string, args ...interface{}) <span class="cov8" title="1">{
        log.ErrorfX(context.Background(), text, args...)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package logging

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        "silvatek.uk/trustedassertions/internal/appcontext"
)

type LogEntry struct {
        Severity    string            `json:"severity"`
        Timestamp   time.Time         `json:"timestamp"`
        Message     interface{}       `json:"message,omitempty"`
        TextPayload interface{}       `json:"textPayload,omitempty"`
        Labels      map[string]string `json:"logging.googleapis.com/labels,omitempty"`
        TraceID     string            `json:"logging.googleapis.com/trace,omitempty"`
        SpanID      string            `json:"logging.googleapis.com/spanId,omitempty"`
        Sampled     bool              `json:"logging.googleapis.com/traceSampled,omitempty"`
        HttpRequest HttpRequestLog    `json:"httpRequest,omitempty"`
}

type HttpRequestLog struct {
        RequestMethod string `json:"requestMethod,omitempty"`
        RequestUrl    string `json:"requestUrl,omitempty"`
}

const TRACE = 1
const DEBUG = 2
const INFO = 3
const WARN = 4
const ERROR = 5
const FATAL = 6

var LogWriter io.Writer = os.Stderr
var StructureLogs bool
var encoder *json.Encoder

var exitHandler = os.Exit

func Print(text string) <span class="cov8" title="1">{
        Printf(text)
}</span>

func Printf(text string, args ...interface{}) <span class="cov8" title="1">{
        Infof(text, args...)
}</span>

func Debug(text string) <span class="cov8" title="1">{
        Debugf(text)
}</span>

func Debugf(text string, args ...interface{}) <span class="cov8" title="1">{
        DebugfX(context.Background(), text, args...)
}</span>

func DebugfX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        WriteLog(ctx, "DEBUG", text, args...)
}</span>

func Info(text string) <span class="cov8" title="1">{
        Infof(text)
}</span>

func Infof(text string, args ...interface{}) <span class="cov8" title="1">{
        InfofX(context.Background(), text, args...)
}</span>

func InfofX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        WriteLog(ctx, "INFO ", text, args...)
}</span>

func Errorf(text string, args ...interface{}) <span class="cov8" title="1">{
        ErrorfX(context.Background(), text, args...)
}</span>

func ErrorfX(ctx context.Context, text string, args ...interface{}) <span class="cov8" title="1">{
        WriteLog(ctx, "ERROR", text, args...)
}</span>

func WriteLog(ctx context.Context, level string, template string, args ...interface{}) <span class="cov8" title="1">{
        WriteNamedLog(ctx, LogWriter, StructureLogs, "", level, template, args...)
}</span>

func WriteNamedLog(ctx context.Context, output io.Writer, structured bool, name string, level string, template string, args ...interface{}) <span class="cov8" title="1">{
        if structured </span><span class="cov8" title="1">{
                encoder = json.NewEncoder(output)
                entry := LogEntry{
                        Severity:  strings.TrimSpace(level),
                        Timestamp: time.Now(),
                        Message:   fmt.Sprintf(template, args...),
                }

                labels := map[string]string{
                        "appname":    "trustedassertions",
                        "loggername": name,
                }

                data, ok := appcontext.ContextData(ctx)
                if ok </span><span class="cov0" title="0">{
                        labels["reqPath"] = data.ReqPath
                        labels["traceparent"] = data.TraceParent
                        entry.HttpRequest.RequestUrl = data.ReqPath
                        entry.HttpRequest.RequestMethod = data.ReqMethod
                        entry.TraceID, entry.SpanID = traceId(data.TraceParent)
                        entry.Sampled = true
                }</span>

                <span class="cov8" title="1">entry.Labels = labels

                encoder.Encode(entry)</span>

        } else<span class="cov8" title="1"> {
                if name == "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(output, level+" "+template+"\n", args...)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(output, level+" ["+name+"] "+template+"\n", args...)
                }</span>
        }
}

func traceId(traceparent string) (string, string) <span class="cov0" title="0">{
        if traceparent == "" </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">parts := strings.Split(traceparent, "-")
        return "projects/trustedassertions/traces/" + parts[1], parts[2]</span>
}

func Fatal(err error) <span class="cov8" title="1">{
        Errorf("Fatal error: %v", err)
        exitHandler(1)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package references

import (
        "crypto/sha256"
        "fmt"
        "net/url"
        "strings"
)

type HashUri struct {
        uri string
}

var EMPTY_URI = HashUri{uri: ""}
var ERROR_URI = HashUri{uri: "ERROR"}
var TYPE_QUERY = "?type="

func MakeUri(hash string, kind string) HashUri <span class="cov8" title="1">{
        uri := "hash://sha256/" + hash
        if kind != "" </span><span class="cov8" title="1">{
                uri = uri + TYPE_QUERY + strings.ToLower(kind)
        }</span>
        <span class="cov8" title="1">return HashUri{uri: uri}</span>
}

func MakeUriB(hash []byte, kind string) HashUri <span class="cov0" title="0">{
        return MakeUri(fmt.Sprintf("%x", hash), kind)
}</span>

func UriFor(ref Referenceable) HashUri <span class="cov0" title="0">{
        return UriFromContent(ref.Content(), ref.Type())
}</span>

// Create a HashUri from a string.
//
// The string can be a hash, a raw URI or an escaped URI.
func UriFromString(str string) HashUri <span class="cov8" title="1">{
        if strings.HasPrefix(str, "hash://sha256/") </span><span class="cov8" title="1">{
                // Is a raw URI string
                return HashUri{uri: str}
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(str, "hash:%2F%2Fsha256%2F") </span><span class="cov8" title="1">{
                // It is an escaped URI string
                return UnescapeUri(str, "")
        }</span>
        <span class="cov8" title="1">return MakeUri(str, "")</span> // Assume it is just a hash
}

// Create a HashUri from content.
//
// The content is hashed using the default algorithm and the HashUri built from that hash.
func UriFromContent(content string, kind string) HashUri <span class="cov0" title="0">{
        hash := sha256.New()
        hash.Write([]byte(content))
        return MakeUriB(hash.Sum(nil), kind)
}</span>

func (u HashUri) Hash() string <span class="cov8" title="1">{
        hash := strings.TrimPrefix(u.String(), "hash://sha256/")
        index := strings.Index(hash, TYPE_QUERY)
        if index &gt; -1 </span><span class="cov8" title="1">{
                hash = hash[:index]
        }</span>
        <span class="cov8" title="1">return hash</span>
}

func (u HashUri) Alg() string <span class="cov8" title="1">{
        return "sha256"
}</span>

func (u HashUri) String() string <span class="cov8" title="1">{
        return u.uri
}</span>

func (u HashUri) Short() string <span class="cov8" title="1">{
        s := u.Hash()
        if len(s) &gt; 8 </span><span class="cov8" title="1">{
                return s[len(s)-8:]
        }</span> else<span class="cov8" title="1"> {
                return s
        }</span>
}

func kind(uri string) string <span class="cov8" title="1">{
        index := strings.Index(uri, TYPE_QUERY)
        if index == -1 </span><span class="cov8" title="1">{
                return "unknown"
        }</span> else<span class="cov8" title="1"> {
                return uri[index+6:]
        }</span>
}

func (u HashUri) Kind() string <span class="cov8" title="1">{
        return kind(u.uri)
}</span>

func (u HashUri) HasType() bool <span class="cov8" title="1">{
        return strings.Contains(u.uri, TYPE_QUERY)
}</span>

func mapPathType(kind string) string <span class="cov8" title="1">{
        kind = strings.ToLower(kind)
        if kind == "unknown" || kind == "" </span><span class="cov8" title="1">{
                return "error"
        }</span> else<span class="cov8" title="1"> if kind == "entity" </span><span class="cov8" title="1">{
                return "entities"
        }</span> else<span class="cov8" title="1"> {
                return kind + "s"
        }</span>
}

func (u HashUri) Unadorned() string <span class="cov8" title="1">{
        s := u.String()
        index := strings.Index(s, TYPE_QUERY)
        if index &gt; -1 </span><span class="cov8" title="1">{
                return s[0:index]
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Returns a URL path-escaped version of the unadorned URI.
//
// This can be used as the key in a key/pair storage model, or in HTTP requests.
func (u HashUri) Escaped() string <span class="cov8" title="1">{
        return url.PathEscape(u.Unadorned())
}</span>

func UnescapeUri(uri string, kind string) HashUri <span class="cov8" title="1">{
        s, err := url.PathUnescape(uri)
        if err != nil </span><span class="cov8" title="1">{
                return EMPTY_URI
        }</span>
        <span class="cov8" title="1">if kind != "" </span><span class="cov8" title="1">{
                s += TYPE_QUERY + kind
        }</span>
        <span class="cov8" title="1">return HashUri{uri: s}</span>
}

func (u HashUri) WebPath() string <span class="cov8" title="1">{
        return "/web/" + mapPathType(u.Kind()) + "/" + u.Hash()
}</span>

func (u HashUri) ApiPath() string <span class="cov8" title="1">{
        return "/api/v1/" + mapPathType(u.Kind()) + "/" + u.Hash()
}</span>

func (u HashUri) IsEmpty() bool <span class="cov0" title="0">{
        return u.uri == ""
}</span>

func (u HashUri) Len() int <span class="cov0" title="0">{
        return len(u.uri)
}</span>

func (u HashUri) WithType(kind string) HashUri <span class="cov8" title="1">{
        u2 := HashUri{uri: u.uri + TYPE_QUERY + strings.ToLower(kind)}
        return u2
}</span>

func (u HashUri) Equals(other HashUri) bool <span class="cov8" title="1">{
        return u.Escaped() == other.Escaped()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package references

import "errors"

type Reference struct {
        Source  HashUri // The source has a reference to the target
        Target  HashUri
        Summary string
}

// Referenceable is a core data type that can be referenced by an assertion.
type Referenceable interface {
        Uri() HashUri
        Type() string
        Content() string
        Summary() string
        TextContent() string
        References() []HashUri
        ParseContent(content string) error
}

var REF_ERROR ReferenceError

type ReferenceError struct {
}

func (e ReferenceError) Uri() HashUri <span class="cov8" title="1">{
        return ERROR_URI
}</span>

func (e ReferenceError) Type() string <span class="cov0" title="0">{
        return "ERROR"
}</span>

func (e ReferenceError) Content() string <span class="cov0" title="0">{
        return "ERROR"
}</span>

func (e ReferenceError) Summary() string <span class="cov0" title="0">{
        return "ERROR"
}</span>

func (e ReferenceError) TextContent() string <span class="cov0" title="0">{
        return "ERROR"
}</span>

func (e ReferenceError) References() []HashUri <span class="cov0" title="0">{
        return make([]HashUri, 0)
}</span>

func (e ReferenceError) ParseContent(content string) error <span class="cov8" title="1">{
        return errors.New("Error URI cannot parse content")
}</span>

func (e ReferenceError) Error() string <span class="cov8" title="1">{
        return "Reference error"
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package search

import (
        "sort"
        "strings"
)

func SearchWords(text string) []string <span class="cov8" title="1">{
        wordMap := make(map[string]bool)
        allWords := strings.Fields(text)
        for _, word := range allWords </span><span class="cov8" title="1">{
                word := strings.ToLower(word)
                word = stripPunctuation(word)
                if len(word) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if ignoredWord(word) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">word = wordRoot(word)
                wordMap[word] = true</span>
        }

        <span class="cov8" title="1">searchWords := make([]string, 0)
        for key, _ := range wordMap </span><span class="cov8" title="1">{
                searchWords = append(searchWords, key)
        }</span>

        <span class="cov8" title="1">sort.Strings(searchWords)

        return searchWords</span>
}

const punct = ".,?;:'\""

func stripPunctuation(word string) string <span class="cov8" title="1">{
        if word == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var stripped strings.Builder
        for _, wordRune := range word </span><span class="cov8" title="1">{
                skip := false
                for _, punctRune := range punct </span><span class="cov8" title="1">{
                        if wordRune == punctRune </span><span class="cov8" title="1">{
                                skip = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !skip </span><span class="cov8" title="1">{
                        stripped.WriteRune(wordRune)
                }</span>
        }
        <span class="cov8" title="1">return stripped.String()</span>
}

var roots = map[string]string{
        "universal": "universe",
        "exports":   "exports",
        "exists":    "exist",
        "truths":    "truth",
        "start":     "begin",
        "seem":      "appear",
}

func wordRoot(word string) string <span class="cov8" title="1">{
        root, ok := roots[word]
        if ok </span><span class="cov8" title="1">{
                return root
        }</span>
        <span class="cov8" title="1">return word</span>
}

var IgnoredWords = []string{"a", "an", "as", "it", "is", "the", "this", "and", "but", "i", "we", "to"}

func ignoredWord(word string) bool <span class="cov8" title="1">{
        for _, w := range IgnoredWords </span><span class="cov8" title="1">{
                if word == w </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func WordsEqual(a []string, b []string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, word := range a </span><span class="cov8" title="1">{
                if b[i] != word </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package statements

import (
        "bytes"

        refs "silvatek.uk/trustedassertions/internal/references"
)

type Statement struct {
        uri     refs.HashUri
        content string
}

func NewStatement(content string) *Statement <span class="cov8" title="1">{
        return &amp;Statement{content: content}
}</span>

func (s Statement) Uri() refs.HashUri <span class="cov8" title="1">{
        if s.uri.IsEmpty() </span><span class="cov8" title="1">{
                s.uri = refs.UriFor(&amp;s)
        }</span>
        <span class="cov8" title="1">return s.uri</span>
}

func (s Statement) Type() string <span class="cov8" title="1">{
        return "Statement"
}</span>

func (s Statement) Content() string <span class="cov8" title="1">{
        return s.content
}</span>

// Returns a summary of the statement, up to 60 characters long.
func (s Statement) Summary() string <span class="cov8" title="1">{
        if len(s.content) &lt; 60 </span><span class="cov8" title="1">{
                return s.content
        }</span> else<span class="cov0" title="0"> {
                return s.content[0:56] + "..."
        }</span>

}

func (s Statement) TextContent() string <span class="cov0" title="0">{
        return s.content
}</span>

func (s Statement) References() []refs.HashUri <span class="cov0" title="0">{
        return []refs.HashUri{}
}</span>

func (s *Statement) ParseContent(content string) error <span class="cov0" title="0">{
        s.content = content
        return nil
}</span>

// NormalizeNewlines normalizes \r\n (windows) and \r (mac)
// into \n (unix)
func NormalizeNewlines(d []byte) []byte <span class="cov0" title="0">{
        // replace CR LF \r\n (windows) with LF \n (unix)
        d = bytes.Replace(d, []byte{13, 10}, []byte{10}, -1)
        // replace CF \r (mac) with LF \n (unix)
        d = bytes.Replace(d, []byte{13}, []byte{10}, -1)
        return d
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package web

import (
        "net/http"
        "strings"

        "github.com/gorilla/mux"
        "silvatek.uk/trustedassertions/internal/appcontext"
)

// Add handlers for URL paths only used by attackers
func AddAttackHandlers(r *mux.Router) <span class="cov8" title="1">{
        // Specific filenames
        for _, path := range []string{
                "/config.json", "/web.config", "/wp-config.php", "/api/.env", "/cloud-config.yml", "/config/production.json", "/feed/", "/.DS_Store", "/about", "/server",
                "/.env", "/.env~", "/.env.dev", "/.env.local", "/.env.example", "/admin/.env", "/_all_dbs", "/login.action",
                "/docker-compose.yml", "/user_secrets.yml", "/secrets.json",
                "/database.sql", "/backup.sql", "/backup.zip", "/backup.tar.gz",
                "/config.php", "/config/database.php", "/server-status", "/phpinfo.php", "/wp-config.php", "/config/database.php", "/xmlrpc.php?rsd",
        } </span><span class="cov8" title="1">{
                r.HandleFunc(path, AttackHandler)
        }</span>

        // Entire directories
        <span class="cov8" title="1">for _, prefix := range []string{
                "/etc/", "/.ssh/", "/.git/", "/.svn", "/_vti_pvt/", "/.vscode/", "/.kube", "/.aws", "/.docker/", "/ecp/", "/admin/", "/debug/", "/_/",
        } </span><span class="cov8" title="1">{
                r.PathPrefix(prefix).HandlerFunc(AttackHandler)
        }</span>

        <span class="cov8" title="1">r.MatcherFunc(func(r *http.Request, rm *mux.RouteMatch) bool </span><span class="cov0" title="0">{
                return strings.Contains(r.URL.Path, "/wp-includes/")
        }</span>).HandlerFunc(AttackHandler)

        <span class="cov8" title="1">r.HandleFunc("/robots.txt", RobotsTxtHandler)</span>
}

// Respond with a 404 status code and no body
func AttackHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.DebugfX(appcontext.NewWebContext(r), "Dropping suspect request: %v", r.URL)
        w.WriteHeader(404)
}</span>

func RobotsTxtHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(200)
        w.Write([]byte("User-agent: *\n"))
        w.Write([]byte("Disallow: /\n"))
        w.Write([]byte("Allow: /robots.txt\n"))
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package web

import (
        "net/http"
        "time"

        "silvatek.uk/trustedassertions/internal/auth"
)

func SetAuthCookie(userId string, w http.ResponseWriter) <span class="cov8" title="1">{
        var cookie *http.Cookie
        if userId == "" </span><span class="cov8" title="1">{
                expiration := time.Now().Add(-24 * time.Hour)
                cookie = &amp;http.Cookie{Name: "auth", Path: "/", Value: "", Expires: expiration, MaxAge: -1, SameSite: http.SameSiteStrictMode}
        }</span> else<span class="cov8" title="1"> {
                cookie = MakeAuthCookie(userId)
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, cookie)</span>
}

func MakeAuthCookie(userId string) *http.Cookie <span class="cov8" title="1">{
        jwt, _ := auth.MakeUserJwt(userId, userJwtKey)
        expiration := time.Now().Add(2 * time.Hour)
        cookie := http.Cookie{Name: "auth", Path: "/", Value: jwt, Expires: expiration, SameSite: http.SameSiteStrictMode}
        return &amp;cookie
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package web

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "github.com/gorilla/mux"
        "github.com/nbutton23/zxcvbn-go"
        "silvatek.uk/trustedassertions/internal/appcontext"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/datastore"
        "silvatek.uk/trustedassertions/internal/entities"
        "silvatek.uk/trustedassertions/internal/references"
)

const AuthError = 3000

var ErrorNoAuth = AppError{ErrorCode: AuthError + 1, UserMessage: "Not logged in"}
var ErrorUserNotFound = AppError{ErrorCode: AuthError + 2, UserMessage: "User not found"}
var ErrorAuthFail = AppError{ErrorCode: AuthError + 5, UserMessage: "Not logged in"}

const RegistrationError = 3100

var ErrorRegCode = AppError{ErrorCode: RegistrationError + 1, UserMessage: "Registration code not valid", HttpCode: 400}
var ErrorPasswordMismatch = AppError{ErrorCode: RegistrationError + 2, UserMessage: "Passwords do not match", HttpCode: 400}
var ErrorBadUsername = AppError{ErrorCode: RegistrationError + 3, UserMessage: "Username is not valid", HttpCode: 400}
var ErrorUserExists = AppError{ErrorCode: RegistrationError + 4, UserMessage: "Username already in use", HttpCode: 400}
var ErrorWeakPassword = AppError{ErrorCode: RegistrationError + 5, UserMessage: "Password is not strong enough", HttpCode: 400}
var ErrorRegistering = AppError{ErrorCode: RegistrationError + 6, UserMessage: "Unexpected error during registration"}

var RegistrationErrors = []AppError{ErrorRegCode, ErrorPasswordMismatch, ErrorBadUsername, ErrorUserExists, ErrorWeakPassword, ErrorRegistering}

var userJwtKey []byte

func addAuthHandlers(r *mux.Router) <span class="cov8" title="1">{
        r.HandleFunc("/web/login", LoginWebHandler)
        r.HandleFunc("/web/logout", LogoutWebHandler)
        r.HandleFunc("/web/register", RegisterWebHandler)
        r.HandleFunc("/web/profile", ProfileWebHandler)

        userJwtKey = auth.MakeJwtKey()
}</span>

func nameOnly(username string) string <span class="cov8" title="1">{
        n := strings.Index(username, "@")
        if n == -1 </span><span class="cov8" title="1">{
                return username
        }</span> else<span class="cov0" title="0"> {
                return username[0:n]
        }</span>
}

// Returns the name of the currently authenticated user, or an empty string.
func authUsername(r *http.Request) string <span class="cov8" title="1">{
        cookie, err := r.Cookie("auth")
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if cookie.Value == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">userName, err := auth.ParseUserJwt(cookie.Value, userJwtKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error parsing user JWT: %v", err)
                return ""
        }</span>
        <span class="cov8" title="1">return userName</span>
}

func LoginWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        if r.Method == "GET" </span><span class="cov8" title="1">{
                errorCode := r.URL.Query().Get("err")

                data := ""
                if errorCode == strconv.Itoa(ErrorAuthFail.ErrorCode) </span><span class="cov8" title="1">{
                        data = "Unable to verify identity"
                }</span>

                <span class="cov8" title="1">RenderWebPage(ctx, "loginform", data, nil, w, r)</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                r.ParseForm()
                userId := r.Form.Get("user_id")

                user, err := datastore.ActiveDataStore.FetchUser(ctx, userId)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("User not found in login attempt: `%s`", userId)
                        http.Redirect(w, r, fmt.Sprintf("/web/login?err=%d", ErrorAuthFail.ErrorCode), http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">if !user.CheckHash(r.Form.Get("password")) </span><span class="cov8" title="1">{
                        log.Errorf("Incorrect password entered for: `%s`", userId)
                        http.Redirect(w, r, fmt.Sprintf("/web/login?err=%d", ErrorAuthFail.ErrorCode), http.StatusSeeOther)
                        return
                }</span>

                <span class="cov8" title="1">SetAuthCookie(userId, w)

                http.Redirect(w, r, "/", http.StatusSeeOther)</span>
        }
}

func LogoutWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        cookie := http.Cookie{Name: "auth", Path: "/", Value: "", MaxAge: -1, SameSite: http.SameSiteStrictMode}
        http.SetCookie(w, &amp;cookie)

        log.DebugfX(ctx, "Cleared auth cookie")

        RenderWebPage(ctx, "loggedout", "", nil, w, r)
}</span>

type RegistrationStore interface {
        FetchUser(ctx context.Context, id string) (auth.User, error)
        StoreUser(ctx context.Context, user auth.User)
        FetchRegistration(ctx context.Context, code string) (auth.Registration, error)
        StoreRegistration(ctx context.Context, reg auth.Registration) error
}

type RegistrationForm struct {
        regCode   string
        userId    string
        password1 string
        password2 string
}

func RegisterWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        if r.Method == "GET" </span><span class="cov8" title="1">{
                errorCode := r.URL.Query().Get("err")

                data := "Error during registration"
                for _, error := range RegistrationErrors </span><span class="cov8" title="1">{
                        if errorCode == strconv.Itoa(error.ErrorCode) </span><span class="cov0" title="0">{
                                data = error.UserMessage
                        }</span>
                }

                <span class="cov8" title="1">RenderWebPage(ctx, "registrationform", data, nil, w, r)</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                r.ParseForm()

                registration := RegistrationForm{
                        regCode:   r.Form.Get("reg_code"),
                        userId:    r.Form.Get("user_id"),
                        password1: r.Form.Get("password1"),
                        password2: r.Form.Get("password2"),
                }

                err := registerUser(ctx, registration, datastore.ActiveDataStore)

                if err != nil </span><span class="cov0" title="0">{
                        http.Redirect(w, r, fmt.Sprintf("/web/register?err=%d", err.ErrorCode), http.StatusSeeOther)
                }</span> else<span class="cov8" title="1"> {
                        http.Redirect(w, r, "/web/login", http.StatusSeeOther)
                }</span>
        }
}

func registerUser(ctx context.Context, registration RegistrationForm, store RegistrationStore) *AppError <span class="cov8" title="1">{
        if registration.regCode == "" </span><span class="cov8" title="1">{
                return &amp;ErrorRegCode
        }</span>

        <span class="cov8" title="1">reg, err := store.FetchRegistration(ctx, registration.regCode)
        if err != nil </span><span class="cov8" title="1">{
                log.DebugfX(ctx, "Could not load registration code %s, %v", registration.regCode, err)
                return &amp;ErrorRegCode
        }</span>
        <span class="cov8" title="1">if reg.Status != "Pending" </span><span class="cov8" title="1">{
                log.DebugfX(ctx, "Attempt to reuse registration code %s (%s)", registration.regCode, reg.Status)
                return &amp;ErrorRegCode
        }</span>

        <span class="cov8" title="1">log.DebugfX(ctx, "Registering with valid registration code %s", registration.regCode)

        user := auth.User{}
        user.Id = registration.userId

        if len(user.Id) &lt; 3 </span><span class="cov8" title="1">{
                return &amp;ErrorBadUsername
        }</span>

        <span class="cov8" title="1">if strings.ContainsAny(user.Id, "/:?") </span><span class="cov8" title="1">{
                return &amp;ErrorBadUsername
        }</span>

        <span class="cov8" title="1">_, err = store.FetchUser(ctx, user.Id)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;ErrorUserExists
        }</span>

        <span class="cov8" title="1">if registration.password1 != registration.password2 </span><span class="cov8" title="1">{
                return &amp;ErrorPasswordMismatch
        }</span>

        <span class="cov8" title="1">strength := zxcvbn.PasswordStrength(registration.password1, []string{user.Id})
        if strength.Score &lt; 3 </span><span class="cov8" title="1">{
                return &amp;ErrorWeakPassword
        }</span>

        <span class="cov8" title="1">user.HashPassword(registration.password1)

        reg.Code = registration.regCode
        reg.UserName = user.Id
        reg.Status = "Complete"
        err = store.StoreRegistration(ctx, reg)
        if err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "Error updating registration status: %v", err)
                return &amp;ErrorRegistering
        }</span>

        <span class="cov8" title="1">store.StoreUser(ctx, user)

        return nil</span>
}

func ProfileWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := appcontext.NewWebContext(r)
        username := authUsername(r)
        if username == "" </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorNoAuth, w, r)
                return
        }</span>

        <span class="cov0" title="0">user, err := datastore.ActiveDataStore.FetchUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorUserNotFound, w, r)
                return
        }</span>

        <span class="cov0" title="0">signers := make([]entities.Entity, len(user.KeyRefs))
        for n, keyRef := range user.KeyRefs </span><span class="cov0" title="0">{
                keyUri := references.UriFromString(keyRef.KeyId)
                entity, _ := datastore.ActiveDataStore.FetchEntity(ctx, keyUri)
                signers[n] = entity
        }</span>

        <span class="cov0" title="0">data := struct {
                UserName string
                User     auth.User
                Entities []entities.Entity
        }{
                UserName: username,
                User:     user,
                Entities: signers,
        }

        RenderWebPage(ctx, "viewprofile", data, nil, w, r)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package web

import (
        "net/http"

        "github.com/gorilla/mux"
        "silvatek.uk/trustedassertions/internal/appcontext"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/datastore"
        "silvatek.uk/trustedassertions/internal/docs"
        ref "silvatek.uk/trustedassertions/internal/references"
)

func ViewDocumentWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        key := mux.Vars(r)["hash"]
        document, _ := datastore.ActiveDataStore.FetchDocument(ctx, ref.MakeUri(key, "document"))

        data := struct {
                Doc       docs.Document
                Title     string
                DocHtml   string
                AuthorUri ref.HashUri
        }{
                Doc:       document,
                Title:     document.Summary(),
                DocHtml:   document.ToHtml(),
                AuthorUri: ref.UriFromString(document.Metadata.Author.Entity),
        }

        RenderWebPage(ctx, "viewdocument", data, nil, w, r)
}</span>

func NewDocumentWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := appcontext.NewWebContext(r)

        username := authUsername(r)
        if username == "" </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorNoAuth, w, r)
                return
        }</span>
        <span class="cov0" title="0">user, err := datastore.ActiveDataStore.FetchUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorUserNotFound.instance("User not found when making new document: "+username), w, r)
                return
        }</span>

        <span class="cov0" title="0">if r.Method == "GET" </span><span class="cov0" title="0">{
                data := struct {
                        User auth.User
                }{
                        User: user,
                }

                RenderWebPage(ctx, "newdocumentform", data, nil, w, r)
        }</span> else<span class="cov0" title="0"> if r.Method == "POST" </span><span class="cov0" title="0">{
                log.InfofX(ctx, "Creating new document")
                r.ParseForm()

                keyId := r.Form.Get("sign_as")
                if !user.HasKey(keyId) </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorKeyAccess.instance("User does not have access to selected signing key"), w, r)
                        return
                }</span>

                <span class="cov0" title="0">keyUri := ref.UriFromString(keyId)

                docxml := r.Form.Get("document")

                doc, err := datastore.CreateDocumentAndAssertions(ctx, docxml, keyUri)
                if err != nil </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorMakeDocument.instance("Error creating new document"), w, r)
                        return
                }</span>

                <span class="cov0" title="0">http.Redirect(w, r, doc.Uri().WebPath(), http.StatusSeeOther)</span>
        }

}
</pre>
		
		<pre class="file" id="file24" style="display: none">package web

import (
        "context"
        "crypto/rand"
        "fmt"
        "math/big"
        "net/http"

        "silvatek.uk/trustedassertions/internal/appcontext"
)

// Application errors, including external and internal messages, error codes and http status codes.
type AppError struct {
        ErrorCode   int       // A numeric code shared by all instances of this error
        HttpCode    int       // The Http status code that is appropriate for this error
        UserMessage string    // An error message suitable to be displayed to the end user
        LogMessage  string    // An error message intended to be written to server logs for debugging
        ErrorId     string    // A unique code for a specific instance of an error at a particular time for a particular user
        template    *AppError // The error on which an instance is based on
}

const FetchError = 1000

var ErrorEntityFetch = AppError{ErrorCode: FetchError + 1, UserMessage: "Error retrieving entity"}
var ErrorAssertionFetch = AppError{ErrorCode: FetchError + 2, UserMessage: "Error retrieving assertion"}

const UpdateError = 2000

var ErrorMakeAssertion = AppError{ErrorCode: UpdateError + 2, UserMessage: "Error making assertion"}
var ErrorKeyFetch = AppError{ErrorCode: UpdateError + 3, UserMessage: "Error fetching key"}
var ErrorKeyAccess = AppError{ErrorCode: UpdateError + 4, UserMessage: "Error accessing key", HttpCode: 403}
var ErrorMakeDocument = AppError{ErrorCode: UpdateError + 5, UserMessage: "Error making document"}

var ErrorFakeTest = AppError{ErrorCode: 9999, UserMessage: "Fake error for testing"}

var errors map[string]AppError

// Create an instance of the error
func (e AppError) instance(logMessage string) AppError <span class="cov8" title="1">{
        if logMessage == "" </span><span class="cov8" title="1">{
                logMessage = e.UserMessage
        }</span>
        <span class="cov8" title="1">if e.HttpCode == 0 </span><span class="cov8" title="1">{
                e.HttpCode = http.StatusInternalServerError
        }</span>

        <span class="cov8" title="1">instance := AppError{
                ErrorCode:   e.ErrorCode,
                HttpCode:    e.HttpCode,
                UserMessage: e.UserMessage,
                LogMessage:  logMessage,
                ErrorId:     makeErrorId(),
                template:    &amp;e,
        }

        return instance</span>
}

func (e AppError) Error() string <span class="cov8" title="1">{
        if e.LogMessage == "" </span><span class="cov0" title="0">{
                return e.UserMessage
        }</span> else<span class="cov8" title="1"> {
                return e.LogMessage
        }</span>
}

func (e AppError) Template() AppError <span class="cov8" title="1">{
        if e.template != nil </span><span class="cov8" title="1">{
                return *e.template
        }</span> else<span class="cov0" title="0"> {
                return e
        }</span>
}

// Error handling for web app.
//
// Logs an error with a message, code and unique ID, then redirects to the error page with the error code and ID.
func HandleError(ctx context.Context, err AppError, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err.ErrorId == "" </span><span class="cov0" title="0">{
                err = err.instance("")
        }</span>
        <span class="cov8" title="1">log.ErrorfX(ctx, fmt.Sprintf("%d : %s (%s)", err.ErrorCode, err.Error(), err.ErrorId))
        errors[fmt.Sprintf("%d", err.ErrorCode)] = err.Template()
        errorPage := fmt.Sprintf("/web/error?err=%d&amp;id=%s", err.ErrorCode, err.ErrorId)
        http.Redirect(w, r, errorPage, http.StatusSeeOther)</span>
}

func makeErrorId() string <span class="cov8" title="1">{
        errorInt, _ := rand.Int(rand.Reader, big.NewInt(0xFFFFFF))
        return fmt.Sprintf("%X", errorInt)
}</span>

// Handler for showing information about an error to the user.
func ErrorPageHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        errorCode := r.URL.Query().Get("err")
        errorId := r.URL.Query().Get("id")

        data := struct {
                ErrorMessage string
                ErrorID      string
        }{
                ErrorMessage: errorMessage(errorCode),
                ErrorID:      errorId,
        }

        RenderWebPageWithStatus(ctx, "error", data, nil, w, r, 500)
}</span>

func errorMessage(errorCode string) string <span class="cov8" title="1">{
        error, ok := errors[errorCode]
        if !ok </span><span class="cov0" title="0">{
                return "Unknown error [" + errorCode + "]"
        }</span>
        <span class="cov8" title="1">return error.UserMessage + " [" + errorCode + "]"</span>
}

func ErrorTestHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        HandleError(appcontext.NewWebContext(r), ErrorFakeTest.instance(""), w, r)
}</span>

func NotFoundWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := appcontext.NewWebContext(r)
        RenderWebPageWithStatus(ctx, "notfound", "", nil, w, r, 404)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package web

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "sync"
        "text/template"

        "github.com/gorilla/csrf"
        "github.com/gorilla/mux"
        "silvatek.uk/trustedassertions/internal/appcontext"
        "silvatek.uk/trustedassertions/internal/assertions"
        "silvatek.uk/trustedassertions/internal/auth"
        "silvatek.uk/trustedassertions/internal/datastore"
        "silvatek.uk/trustedassertions/internal/docs"
        "silvatek.uk/trustedassertions/internal/entities"
        "silvatek.uk/trustedassertions/internal/logging"
        ref "silvatek.uk/trustedassertions/internal/references"
        "silvatek.uk/trustedassertions/internal/statements"
)

var TemplateDir string
var DefaultEntityUri ref.HashUri

var log = logging.GetLogger("web")

func AddHandlers(r *mux.Router) <span class="cov8" title="1">{
        r.HandleFunc("/", HomeWebHandler)
        r.HandleFunc("/web/statements/{hash}", ViewStatementWebHandler)
        r.HandleFunc("/web/entities/{hash}", ViewEntityWebHandler)
        r.HandleFunc("/web/assertions/{hash}", ViewAssertionWebHandler)
        r.HandleFunc("/web/documents/{hash}", ViewDocumentWebHandler)
        r.HandleFunc("/web/broken", ErrorTestHandler)
        r.HandleFunc("/web/error", ErrorPageHandler)
        r.HandleFunc("/web/newstatement", NewStatementWebHandler)
        r.HandleFunc("/web/newentity", NewEntityWebHandler)
        r.HandleFunc("/web/newdocument", NewDocumentWebHandler)
        r.HandleFunc("/web/statements/{hash}/addassertion", AddStatementAssertionWebHandler)
        r.HandleFunc("/web/search", SearchWebHandler)
        r.HandleFunc("/web/share", SharePageWebHandler)
        r.HandleFunc("/web/qrcode", qrCodeGenerator)

        r.NotFoundHandler = http.HandlerFunc(NotFoundWebHandler)

        addAuthHandlers(r)
        AddAttackHandlers(r)

        staticDir := http.Dir(TemplateDir + "/static")
        fs := http.FileServer(staticDir)
        r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", fs))
        r.PathPrefix("/google").Handler(fs)

        errors = make(map[string]AppError)
}</span>

type PageData struct {
        LeftMenu  PageMenu
        RightMenu PageMenu
        AuthUser  string
        AuthName  string
        LoggedIn  bool
        CsrfField interface{}
        Detail    interface{}
}

func RenderWebPageWithStatus(ctx context.Context, pageName string, data interface{}, menu []PageMenuItem, w http.ResponseWriter, r *http.Request, status int) <span class="cov8" title="1">{
        dir := TemplateDir

        t, err := template.ParseFiles(dir+"/"+"base.html", dir+"/"+pageName+".html")
        if err != nil </span><span class="cov0" title="0">{
                msg := http.StatusText(http.StatusInternalServerError)
                log.ErrorfX(ctx, "Error parsing template: %+v", err)
                http.Error(w, msg, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">username := authUsername(r)
        pageData := PageData{
                AuthUser:  username,
                AuthName:  nameOnly(username),
                LoggedIn:  username != "",
                CsrfField: csrf.TemplateField(r),
                Detail:    data,
        }

        if pageName == "loggedout" </span><span class="cov8" title="1">{
                SetAuthCookie("", w)
        }</span> else<span class="cov8" title="1"> {
                SetAuthCookie(username, w) // Refresh the auth cookie
        }</span>

        <span class="cov8" title="1">leftMenu := PageMenu{}
        if pageName != "index" </span><span class="cov8" title="1">{
                leftMenu.AddLink("Home", "/")
        }</span>
        <span class="cov8" title="1">for _, item := range menu </span><span class="cov8" title="1">{
                leftMenu.AddItem(&amp;item)
        }</span>

        <span class="cov8" title="1">pageData.LeftMenu = leftMenu

        rightMenu := PageMenu{}

        if pageName == "loggedout" || pageName == "loginform" </span>{<span class="cov8" title="1">
                //
        }</span> else<span class="cov8" title="1"> if username == "" </span><span class="cov0" title="0">{
                rightMenu.AddRightLink("Login", "/web/login")
                rightMenu.AddRightLink("Register", "/web/register")
        }</span> else<span class="cov8" title="1"> {
                rightMenu.AddRightLink(nameOnly(username), "/web/profile")
                rightMenu.AddRightLink("Logout", "/web/logout")
        }</span>
        <span class="cov8" title="1">pageData.RightMenu = rightMenu

        if status != 0 </span><span class="cov8" title="1">{
                w.WriteHeader(status)
        }</span>

        <span class="cov8" title="1">if err := t.ExecuteTemplate(w, "base", pageData); err != nil </span><span class="cov0" title="0">{
                log.ErrorfX(ctx, "template.Execute: %v", err)
                msg := http.StatusText(http.StatusInternalServerError)
                http.Error(w, msg, http.StatusInternalServerError)
        }</span>
}

func RenderWebPage(ctx context.Context, pageName string, data interface{}, menu []PageMenuItem, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        RenderWebPageWithStatus(ctx, pageName, data, menu, w, r, 200)
}</span>

func HomeWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        log.DebugfX(ctx, "Home page accessed")

        data := struct {
                DefaultDocument ref.HashUri
        }{
                DefaultDocument: docs.DefaultDocumentUri,
        }

        RenderWebPage(ctx, "index", data, nil, w, r)
}</span>

func ViewStatementWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        key := mux.Vars(r)["hash"]
        statement, _ := datastore.ActiveDataStore.FetchStatement(ctx, ref.MakeUri(key, "statement"))

        refs, _ := datastore.ActiveDataStore.FetchRefs(ctx, statement.Uri())
        enrichReferencesTo(ctx, &amp;statement, refs)

        data := struct {
                Uri        ref.HashUri
                ShortUri   string
                Content    string
                ApiLink    string
                References []ref.Reference
        }{
                Uri:        statement.Uri(),
                ShortUri:   statement.Uri().Short(),
                Content:    statement.Content(),
                ApiLink:    statement.Uri().ApiPath(),
                References: refs,
        }

        menu := []PageMenuItem{
                {Text: "Raw", Target: statement.Uri().ApiPath()},
                {Text: "Share", Target: "/web/share?hash=" + statement.Uri().Hash() + "&amp;type=statement"},
        }

        RenderWebPage(ctx, "viewstatement", data, menu, w, r)
}</span>

func enrichReferencesTo(ctx context.Context, target ref.Referenceable, refs []ref.Reference) <span class="cov8" title="1">{
        var wg sync.WaitGroup

        for n, reference := range refs </span><span class="cov8" title="1">{
                if reference.Summary == "" </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(ref *ref.Reference) </span><span class="cov0" title="0">{
                                // Construct a summary for the reference
                                datastore.MakeSummary(ctx, &amp;target, ref, datastore.ActiveDataStore)

                                // Store the newly summarised reference back in the datastore
                                datastore.ActiveDataStore.StoreRef(ctx, *ref)

                                refs[n] = *ref
                                wg.Done()
                        }</span>(&amp;reference)
                }
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

func ViewAssertionWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        key := mux.Vars(r)["hash"]
        uri := ref.MakeUri(key, "assertion")
        assertion, _ := datastore.ActiveDataStore.FetchAssertion(ctx, uri)

        issuerUri := ref.UriFromString(assertion.Issuer)
        if !issuerUri.HasType() </span><span class="cov8" title="1">{
                issuerUri = issuerUri.WithType("entity")
        }</span>

        <span class="cov8" title="1">issuer, _ := datastore.ActiveDataStore.FetchEntity(ctx, issuerUri)

        subjectUri := ref.UriFromString(assertion.Subject)
        if !subjectUri.HasType() </span><span class="cov8" title="1">{
                subjectUri = subjectUri.WithType("statement")
        }</span>

        <span class="cov8" title="1">subject, _ := datastore.ActiveDataStore.FetchStatement(ctx, subjectUri)

        refs, _ := datastore.ActiveDataStore.FetchRefs(ctx, uri)
        enrichReferencesTo(ctx, &amp;assertion, refs)

        data := struct {
                Uri         string
                ShortUri    string
                Assertion   assertions.Assertion
                IssuerLink  string
                IssuerName  string
                SubjectLink string
                SubjectText string
                ApiLink     string
                References  []ref.Reference
        }{
                Uri:         assertion.Uri().String(),
                ShortUri:    assertion.Uri().Short(),
                Assertion:   assertion,
                ApiLink:     assertion.Uri().ApiPath(),
                IssuerLink:  issuerUri.WebPath(),
                IssuerName:  issuer.CommonName,
                SubjectLink: subjectUri.WebPath(),
                SubjectText: subject.Content(),
                References:  refs,
        }

        menu := []PageMenuItem{
                {Text: "Raw", Target: assertion.Uri().ApiPath()},
                {Text: "Share", Target: "/web/share?hash=" + assertion.Uri().Hash() + "&amp;type=assertion"},
        }

        RenderWebPage(ctx, "viewassertion", data, menu, w, r)</span>
}

func ViewEntityWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        key := mux.Vars(r)["hash"]

        uri := ref.MakeUri(key, "entity")
        entity, err := datastore.ActiveDataStore.FetchEntity(ctx, uri)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorEntityFetch.instance("Error fetching entity "+uri.String()), w, r)
                return
        }</span>

        <span class="cov8" title="1">refs, _ := datastore.ActiveDataStore.FetchRefs(ctx, entity.Uri())
        enrichReferencesTo(ctx, &amp;entity, refs)

        data := struct {
                Uri        string
                ShortUri   string
                CommonName string
                ApiLink    string
                PublicKey  string
                References []ref.Reference
        }{
                Uri:        uri.String(),
                ShortUri:   uri.Short(),
                CommonName: entity.CommonName,
                PublicKey:  fmt.Sprintf("%v", entity.PublicKey),
                ApiLink:    uri.ApiPath(),
                References: refs,
        }

        menu := []PageMenuItem{
                {Text: "Raw", Target: entity.Uri().ApiPath()},
                {Text: "Share", Target: "/web/share?hash=" + entity.Uri().Hash() + "&amp;type=entity"},
        }

        RenderWebPage(ctx, "viewentity", data, menu, w, r)</span>
}

func NewStatementWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        username := authUsername(r)
        if username == "" </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorNoAuth, w, r)
                return
        }</span>
        <span class="cov8" title="1">user, err := datastore.ActiveDataStore.FetchUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorUserNotFound.instance("User not found: "+username), w, r)
                return
        }</span>

        <span class="cov8" title="1">if r.Method == "GET" </span><span class="cov8" title="1">{
                RenderWebPage(ctx, "newstatementform", user, nil, w, r)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                log.InfofX(ctx, "Creating new statement and assertion")
                r.ParseForm()
                content := r.Form.Get("statement")
                log.DebugfX(ctx, "Web post of new statement: %s", content)

                keyId := r.Form.Get("sign_as")
                log.DebugfX(ctx, "Signing key ID: %s", keyId)

                confidence, _ := strconv.ParseFloat(r.Form.Get("confidence"), 32)

                keyUri := ref.UriFromString(keyId)

                if !user.HasKey(keyId) </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorKeyAccess.instance("User does not have access to selected signing key"), w, r)
                        return
                }</span>

                <span class="cov8" title="1">assertion, err := datastore.CreateStatementAndAssertion(ctx, content, keyUri, "IsTrue", confidence)
                if err != nil </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorMakeAssertion.instance("Error making new statement and assertion"), w, r)
                        return
                }</span>

                // Redirect the user to the assertion
                <span class="cov8" title="1">http.Redirect(w, r, assertion.Uri().WebPath(), http.StatusSeeOther)

                log.Infof("Redirecting to %s", assertion.Uri().WebPath())</span>
        }
}

func SearchWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        query := r.URL.Query().Get("query")

        query, _ = url.QueryUnescape(query)

        results, _ := datastore.ActiveDataStore.Search(ctx, query)

        data := struct {
                Query   string
                Results []datastore.SearchResult
        }{
                Query:   query,
                Results: results,
        }

        RenderWebPage(ctx, "searchresults", data, nil, w, r)
}</span>

func NewEntityWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)
        username := authUsername(r)
        if username == "" </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorNoAuth, w, r)
                return
        }</span>
        <span class="cov8" title="1">user, err := datastore.ActiveDataStore.FetchUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorUserNotFound.instance("User not found when making new entity: "+username), w, r)
                return
        }</span>

        <span class="cov8" title="1">if r.Method == "GET" </span><span class="cov8" title="1">{
                RenderWebPage(ctx, "newentityform", user, nil, w, r)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                log.InfofX(ctx, "Creating new entity and signing key")
                r.ParseForm()
                commonName := r.Form.Get("commonname")
                log.DebugfX(ctx, "Common name: %s", commonName)

                privateKey, _ := rsa.GenerateKey(rand.Reader, 2048)
                entity := entities.Entity{CommonName: commonName}
                entity.MakeCertificate(privateKey)

                datastore.ActiveDataStore.Store(ctx, &amp;entity)

                datastore.ActiveDataStore.StoreKey(entity.Uri(), entities.PrivateKeyToString(privateKey))

                user.AddKeyRef(entity.Uri().Escaped(), entity.CommonName)
                datastore.ActiveDataStore.StoreUser(ctx, user)

                // Redirect the user to the assertion
                http.Redirect(w, r, entity.Uri().WebPath(), http.StatusSeeOther)

                log.Infof("Redirecting to %s", entity.Uri().WebPath())
        }</span>
}

func AddStatementAssertionWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        username := authUsername(r)
        if username == "" </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorNoAuth, w, r)
                return
        }</span>
        <span class="cov8" title="1">user, err := datastore.ActiveDataStore.FetchUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                HandleError(ctx, ErrorUserNotFound.instance("User not found when making new statement: "+username), w, r)
                return
        }</span>

        <span class="cov8" title="1">statementHash := mux.Vars(r)["hash"]

        if r.Method == "GET" </span><span class="cov8" title="1">{
                statement, err := datastore.ActiveDataStore.FetchStatement(ctx, ref.MakeUri(statementHash, "statement"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error fetching statement: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Debugf("Statement content = %s", statement.Content())
                }</span>

                <span class="cov8" title="1">data := struct {
                        Statement statements.Statement
                        User      auth.User
                }{
                        Statement: statement,
                        User:      user,
                }

                RenderWebPage(ctx, "addassertionform", data, nil, w, r)</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                log.InfofX(ctx, "Creating new assertion for statement")
                r.ParseForm()

                keyId := r.Form.Get("sign_as")
                log.DebugfX(ctx, "Signing key ID: %s", keyId)

                keyUri := ref.UriFromString(keyId)

                if !user.HasKey(keyId) </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorKeyAccess.instance("User does not have access to selected signing key"), w, r)
                        return
                }</span>

                <span class="cov8" title="1">b64key, err := datastore.ActiveDataStore.FetchKey(keyUri)
                if err != nil </span><span class="cov0" title="0">{
                        HandleError(ctx, ErrorKeyFetch.instance("Error fetching entity private key"), w, r)
                        return
                }</span>
                <span class="cov8" title="1">privateKey := entities.PrivateKeyFromString(b64key)

                entity, _ := datastore.ActiveDataStore.FetchEntity(ctx, keyUri)

                su := ref.MakeUri(statementHash, "statement")

                confidence, _ := strconv.ParseFloat(r.Form.Get("confidence"), 32)
                kind := r.Form.Get("assertion_type")

                assertion := datastore.CreateAssertion(ctx, su, entity.Uri(), kind, confidence, privateKey)

                // Redirect the user to the assertion
                http.Redirect(w, r, assertion.Uri().WebPath(), http.StatusSeeOther)

                log.DebugfX(ctx, "Redirecting to %s", assertion.Uri().WebPath())</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package web

type PageMenu struct {
        Items []PageMenuItem
}

type PageMenuItem struct {
        Menu      *PageMenu
        Text      string
        Target    string
        Separator string
        Style     string
}

func (i PageMenuItem) IsLink() bool <span class="cov8" title="1">{
        return i.Target != ""
}</span>

func (m *PageMenu) AddItem(item *PageMenuItem) <span class="cov8" title="1">{
        if m.Items == nil </span><span class="cov8" title="1">{
                m.Items = make([]PageMenuItem, 0)
        }</span>

        <span class="cov8" title="1">n := len(m.Items)
        if n &gt; 0 </span><span class="cov8" title="1">{
                item.Separator = "|"
        }</span>

        <span class="cov8" title="1">m.Items = append(m.Items, *item)</span>
}

func (m *PageMenu) AddLink(text string, target string) <span class="cov8" title="1">{
        item := PageMenuItem{
                Menu:   m,
                Text:   text,
                Target: target,
                Style:  "leftlink",
        }
        m.AddItem(&amp;item)
}</span>

func (m *PageMenu) AddRightLink(text string, target string) <span class="cov8" title="1">{
        item := PageMenuItem{
                Menu:   m,
                Text:   text,
                Target: target,
                Style:  "rightlink",
        }
        m.AddItem(&amp;item)
}</span>

func (m *PageMenu) AddRightText(text string) <span class="cov0" title="0">{
        item := PageMenuItem{
                Menu:  m,
                Text:  text,
                Style: "rightlink",
        }
        m.AddItem(&amp;item)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package web

import (
        "io"
        "net/http"
        "strings"

        "github.com/skip2/go-qrcode"
        "silvatek.uk/trustedassertions/internal/appcontext"
)

func SharePageWebHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := appcontext.NewWebContext(r)

        hash := r.URL.Query().Get("hash")
        kind := r.URL.Query().Get("type")

        data := struct {
                Url     string
                QrCode  string
                HashUri string
        }{
                Url:     server(r.Host) + "/web/" + kind + "s/" + hash,
                QrCode:  server(r.Host) + "/web/qrcode?hash=" + hash + "&amp;type=" + kind,
                HashUri: "hash://sha256/" + hash + "?type=" + kind,
        }

        RenderWebPage(ctx, "sharepage", data, nil, w, r)
}</span>

func qrCodeGenerator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hash := r.URL.Query().Get("hash")
        kind := r.URL.Query().Get("type")
        host := r.Host

        headers := w.Header()
        headers.Add("Content-Type", "image/png")
        w.WriteHeader(http.StatusOK)

        writeQrCode(host, hash, kind, w)
}</span>

func writeQrCode(host string, hash string, kind string, w io.Writer) <span class="cov8" title="1">{
        uri := server(host) + "/web/" + kind + "s/" + hash

        q, _ := qrcode.New(uri, qrcode.High)
        q.Write(320, w)
}</span>

func server(host string) string <span class="cov8" title="1">{
        if strings.Contains(host, "localhost") </span><span class="cov8" title="1">{
                return "http://" + host
        }</span> else<span class="cov8" title="1"> {
                return "https://" + host
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package webtest

import (
        "net/http"
        "net/http/cookiejar"
        "net/http/httptest"
        "net/url"
        "strings"
        "testing"

        "github.com/PuerkitoBio/goquery"
        // "silvatek.uk/trustedassertions/internal/auth"
)

type WebTest struct {
        t *testing.T
        // User       *auth.User
        Server     *httptest.Server
        Passwd     string
        AuthCookie *http.Cookie
        Client     *http.Client
}

func (wt *WebTest) Close() <span class="cov8" title="1">{
        wt.Server.Close()
}</span>

type WebPage struct {
        wt           *WebTest
        url          string
        requestError error
        response     *http.Response
        statusCode   int
        htmlError    error
        html         *goquery.Document
}

func MakeWebTest(t *testing.T) *WebTest <span class="cov8" title="1">{
        wt := WebTest{t: t}

        jar, _ := cookiejar.New(nil)
        wt.Client = &amp;http.Client{
                Jar: jar,
        }

        return &amp;wt
}</span>

func (wt *WebTest) GetPage(path string) *WebPage <span class="cov8" title="1">{
        url := wt.Server.URL + path
        page := WebPage{url: url, wt: wt}

        req, _ := http.NewRequest("GET", url, nil)
        if wt.AuthCookie != nil </span><span class="cov8" title="1">{
                req.AddCookie(wt.AuthCookie)
        }</span>

        <span class="cov8" title="1">page.response, page.requestError = wt.Client.Do(req)

        if page.requestError != nil </span><span class="cov0" title="0">{
                wt.t.Errorf("Error fetching %s, %v", url, page.requestError)
                return &amp;page
        }</span>

        <span class="cov8" title="1">page.statusCode = page.response.StatusCode

        defer page.response.Body.Close()
        page.html, page.htmlError = goquery.NewDocumentFromReader(page.response.Body)

        return &amp;page</span>
}

func (wt *WebTest) PostFormData(path string, data url.Values) *WebPage <span class="cov8" title="1">{
        url := wt.Server.URL + path
        req, _ := http.NewRequest("POST", url, strings.NewReader(data.Encode()))
        if wt.AuthCookie != nil </span><span class="cov8" title="1">{
                req.AddCookie(wt.AuthCookie)
        }</span>
        <span class="cov8" title="1">req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

        page := WebPage{url: url, wt: wt}

        response, err := wt.Client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                page.requestError = err
                return &amp;page
        }</span>

        <span class="cov8" title="1">page.response = response
        page.statusCode = response.StatusCode
        if page.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                return &amp;page
        }</span>

        <span class="cov8" title="1">defer page.response.Body.Close()
        page.html, page.htmlError = goquery.NewDocumentFromReader(page.response.Body)

        return &amp;page</span>
}

func (page *WebPage) ok() bool <span class="cov8" title="1">{
        return (page.requestError == nil) &amp;&amp; (page.statusCode &lt; 400) &amp;&amp; (page.htmlError == nil)
}</span>

func (page *WebPage) Find(q string) string <span class="cov8" title="1">{
        if !page.ok() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return page.html.Find(q).Text()</span>
}

func (page *WebPage) AssertSuccessResponse() <span class="cov8" title="1">{
        if page.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                page.wt.t.Errorf("Response code indicates error: %d", page.statusCode)
        }</span>
}

func (page *WebPage) AssertErrorResponse() <span class="cov0" title="0">{
        if page.statusCode &lt; 400 </span><span class="cov0" title="0">{
                page.wt.t.Errorf("Response code does not indicate error: %d", page.statusCode)
        }</span>
}

func (page *WebPage) AssertHtmlQuery(query string, expected string) <span class="cov8" title="1">{
        if !page.ok() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">results := page.html.Find(query)
        if !strings.Contains(results.Text(), expected) </span><span class="cov0" title="0">{
                page.wt.t.Errorf("Did not find `%s` in [%s]", expected, query)
        }</span>
}

func (page *WebPage) AssertHasCookie(name string) <span class="cov8" title="1">{
        if !page.ok() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">url, _ := url.Parse(page.wt.Server.URL + "/")

        for _, cookie := range page.wt.Client.Jar.Cookies(url) </span><span class="cov8" title="1">{
                if cookie.Name == name </span><span class="cov8" title="1">{
                        return // cookie found, no error
                }</span>
        }

        <span class="cov0" title="0">page.wt.t.Errorf("`%s` cookie not found", name)</span>
}

func (page *WebPage) AssertNoCookie(name string) <span class="cov8" title="1">{
        if !page.ok() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">url, _ := url.Parse(page.wt.Server.URL + "/")

        for _, cookie := range page.wt.Client.Jar.Cookies(url) </span><span class="cov0" title="0">{
                if cookie.Name == name </span><span class="cov0" title="0">{
                        if cookie.Value != "" </span><span class="cov0" title="0">{
                                page.wt.t.Errorf("`%s` cookie found", name)
                        }</span>
                }
        }

}

func (page *WebPage) Text() string <span class="cov0" title="0">{
        return page.html.Text()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
